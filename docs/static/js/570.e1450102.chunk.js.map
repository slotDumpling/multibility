{"version":3,"file":"static/js/570.e1450102.chunk.js","mappings":"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","sources":["lib/color.ts","lib/draw/DrawState.ts","lib/network/http.ts","lib/note/archive.ts","lib/note/note.ts","lib/user.ts"],"sourcesContent":["export const colors = [\r\n  \"#000000\",\r\n  \"#9ca3af\",\r\n  \"#64748b\",\r\n  \"#78716c\",\r\n  \"#f97316\",\r\n  \"#eab308\",\r\n  \"#84cc16\",\r\n  \"#22c55e\",\r\n  \"#10b981\",\r\n  \"#14b8a6\",\r\n  \"#06b6d4\",\r\n  \"#0ea5e9\",\r\n  \"#3b82f6\",\r\n  \"#6366f1\",\r\n  \"#8b5cf6\",\r\n  \"#a855f7\",\r\n  \"#d946ef\",\r\n  \"#ec4899\",\r\n  \"#f43f5e\",\r\n  \"#ef4444\",\r\n];\r\n\r\nexport const getRandomColor = () => {\r\n  const index = Math.floor(Math.random() * colors.length);\r\n  return colors[index];\r\n};\r\n\r\nconst hashCode = (str: string) => {\r\n  let hash = 0;\r\n  if (str.length === 0) return hash;\r\n  for (let i = 0; i < str.length; i++) {\r\n    const chr = str.charCodeAt(i);\r\n    hash = (hash << 5) - hash + chr;\r\n    hash |= 0;\r\n  }\r\n  return Math.abs(hash);\r\n};\r\n\r\nexport const getHashedColor = (str: string) => {\r\n  const index = hashCode(str) % colors.length;\r\n  return colors[index];\r\n};\r\n","import { List, Record, OrderedMap } from \"immutable\";\r\nimport { v4 as getUid } from \"uuid\";\r\nimport Heap from \"heap\";\r\n\r\nexport const WIDTH = 2000;\r\n\r\nexport interface Stroke {\r\n  uid: string;\r\n  pathData: string;\r\n  timestamp: number;\r\n}\r\n\r\nexport type StrokeRecord = globalThis.Record<string, Stroke>;\r\nexport type Mutation = [string, string];\r\n\r\nexport type Operation =\r\n  | {\r\n      type: \"add\";\r\n      stroke: Stroke;\r\n    }\r\n  | {\r\n      type: \"erase\";\r\n      erased: string[];\r\n    }\r\n  | {\r\n      type: \"mutate\";\r\n      mutations: Mutation[];\r\n    }\r\n  | {\r\n      type: \"undo\";\r\n    }\r\n  | {\r\n      type: \"redo\";\r\n    };\r\n\r\ninterface DrawStateRecordType {\r\n  strokes: OrderedMap<string, Stroke>;\r\n  undoStack: List<DrawStateRecord>;\r\n  historyStack: List<DrawStateRecord>;\r\n}\r\n\r\ntype DrawStateRecord = Record<DrawStateRecordType>;\r\n\r\nconst defaultRecord: Readonly<DrawStateRecordType> = {\r\n  strokes: OrderedMap(),\r\n  undoStack: List(),\r\n  historyStack: List(),\r\n};\r\n\r\nconst defaultFactory = Record(defaultRecord);\r\n\r\nexport interface FlatState {\r\n  strokes: StrokeRecord;\r\n  operations?: Operation[];\r\n}\r\n\r\nexport const getDefaultFlatState = (): FlatState => {\r\n  return { strokes: {} };\r\n};\r\n\r\nexport class DrawState {\r\n  constructor(\r\n    private immutable: DrawStateRecord,\r\n    public readonly width: number,\r\n    public readonly height: number,\r\n    public lastOp?: Operation\r\n  ) {}\r\n\r\n  getImmutable() {\r\n    return this.immutable;\r\n  }\r\n\r\n  getUndoStack() {\r\n    return this.getImmutable().get(\"undoStack\");\r\n  }\r\n\r\n  getHistoryStack() {\r\n    return this.getImmutable().get(\"historyStack\");\r\n  }\r\n\r\n  getStrokeMap() {\r\n    return this.getImmutable().get(\"strokes\");\r\n  }\r\n\r\n  getStrokeList(): Stroke[] {\r\n    return this.getStrokeMap()\r\n      .toArray()\r\n      .map(([_, stroke]) => stroke);\r\n  }\r\n\r\n  getLastStroke() {\r\n    return this.getStrokeMap().last();\r\n  }\r\n\r\n  isEmpty() {\r\n    return this.getStrokeMap().size === 0;\r\n  }\r\n\r\n  hasStroke(uid: string) {\r\n    return this.getStrokeMap().has(uid);\r\n  }\r\n\r\n  static createEmpty(width: number, height: number) {\r\n    return new DrawState(defaultFactory(), width, height);\r\n  }\r\n\r\n  static undo(drawState: DrawState) {\r\n    const lastOp: Operation = { type: \"undo\" };\r\n    const lastRecord = drawState.getHistoryStack().last();\r\n    if (!lastRecord) return drawState;\r\n    const undoStack = drawState\r\n      .getUndoStack()\r\n      .unshift(drawState.getImmutable());\r\n    return new DrawState(\r\n      lastRecord.set(\"undoStack\", undoStack),\r\n      drawState.width,\r\n      drawState.height,\r\n      lastOp\r\n    );\r\n  }\r\n\r\n  static redo(drawState: DrawState) {\r\n    const lastOp: Operation = { type: \"redo\" };\r\n\r\n    const nextRecord = drawState.getUndoStack().first();\r\n    if (!nextRecord) return drawState;\r\n    return new DrawState(nextRecord, drawState.width, drawState.height, lastOp);\r\n  }\r\n\r\n  static addStroke(drawState: DrawState, pathData: string) {\r\n    const uid = getUid();\r\n    const timestamp = Date.now();\r\n    const stroke = { pathData, uid, timestamp };\r\n    return DrawState.pushStroke(drawState, stroke);\r\n  }\r\n\r\n  static pushStroke(drawState: DrawState, stroke: Stroke) {\r\n    const { uid } = stroke;\r\n    const prevRecord = drawState.getImmutable();\r\n    const currRecord = prevRecord\r\n      .update(\"strokes\", (s) => s.set(uid, stroke))\r\n      .update(\"historyStack\", (s) => s.push(prevRecord))\r\n      .delete(\"undoStack\");\r\n\r\n    const lastOp: Operation = { type: \"add\", stroke };\r\n\r\n    return new DrawState(currRecord, drawState.width, drawState.height, lastOp);\r\n  }\r\n\r\n  static eraseStrokes(drawState: DrawState, erased: string[]) {\r\n    if (erased.length === 0) return drawState;\r\n    const prevRecord = drawState.getImmutable();\r\n    const currRecord = prevRecord\r\n      .update(\"strokes\", (m) => m.deleteAll(erased))\r\n      .update(\"historyStack\", (s) => s.push(prevRecord))\r\n      .delete(\"undoStack\");\r\n\r\n    const lastOp: Operation = { type: \"erase\", erased };\r\n\r\n    return new DrawState(currRecord, drawState.width, drawState.height, lastOp);\r\n  }\r\n\r\n  static mutateStrokes(drawState: DrawState, mutations: Mutation[]) {\r\n    if (mutations.length === 0) return drawState;\r\n    const prevRecord = drawState.getImmutable();\r\n    let strokes = drawState.getStrokeMap();\r\n    mutations.forEach(\r\n      ([uid, pathData]) =>\r\n        (strokes = strokes.update(\r\n          uid,\r\n          { uid, pathData, timestamp: Date.now() },\r\n          (s) => ({ ...s, pathData })\r\n        ))\r\n    );\r\n    const currRecord = prevRecord\r\n      .set(\"strokes\", strokes)\r\n      .update(\"historyStack\", (s) => s.push(prevRecord))\r\n      .delete(\"undoStack\");\r\n\r\n    const lastOp: Operation = { type: \"mutate\", mutations };\r\n\r\n    return new DrawState(currRecord, drawState.width, drawState.height, lastOp);\r\n  }\r\n\r\n  static syncStrokeTime(drawState: DrawState, stroke: Stroke) {\r\n    const { uid, timestamp } = stroke;\r\n    const prevStroke = drawState.getStrokeMap().get(uid);\r\n    if (!prevStroke) return;\r\n    prevStroke.timestamp = timestamp;\r\n  }\r\n\r\n  static pushOperation(drawState: DrawState, op: Operation) {\r\n    switch (op.type) {\r\n      case \"add\":\r\n        return DrawState.pushStroke(drawState, op.stroke);\r\n      case \"erase\":\r\n        return DrawState.eraseStrokes(drawState, op.erased);\r\n      case \"mutate\":\r\n        return DrawState.mutateStrokes(drawState, op.mutations);\r\n      case \"undo\":\r\n        return DrawState.undo(drawState);\r\n      case \"redo\":\r\n        return DrawState.redo(drawState);\r\n    }\r\n  }\r\n\r\n  static flaten(drawState: DrawState): FlatState {\r\n    const strokes = drawState.getImmutable().get(\"strokes\").toObject();\r\n    return { strokes };\r\n  }\r\n\r\n  static loadFromFlat(\r\n    flatState: FlatState,\r\n    width: number,\r\n    height: number\r\n  ): DrawState {\r\n    const { strokes, operations } = flatState;\r\n    let ds = new DrawState(\r\n      defaultFactory().set(\"strokes\", OrderedMap(strokes)),\r\n      width,\r\n      height\r\n    );\r\n    operations?.forEach((op) => (ds = DrawState.pushOperation(ds, op)));\r\n    return ds;\r\n  }\r\n\r\n  static mergeStates(states: DrawState[]): Stroke[] {\r\n    const iterators = states.map((ds) => ds.getStrokeMap().values());\r\n    const mergedStrokes = [];\r\n    const heap = new Heap<[Stroke, number]>(\r\n      ([s0], [s1]) => s0.timestamp - s1.timestamp\r\n    );\r\n\r\n    iterators.forEach((iter, index) => {\r\n      const { value, done } = iter.next();\r\n      done || heap.push([value, index]);\r\n    });\r\n\r\n    while (heap.size() > 0) {\r\n      const record = heap.pop();\r\n      if (!record) break;\r\n      const [stroke, index] = record;\r\n      mergedStrokes.push(stroke);\r\n\r\n      const { value, done } = iterators[index].next();\r\n      done || heap.push([value, index]);\r\n    }\r\n    return mergedStrokes;\r\n  }\r\n}\r\n","import axios from \"axios\";\r\nimport { removePageTimg, TeamNoteInfo, TeamPage, TeamPageInfo } from \"../note/note\";\r\nimport { loadNote, saveTeamNote, updateTeamNote } from \"../note/archive\";\r\nimport { getUserID } from \"../user\";\r\n\r\nexport let BASE_URL = \"https://api.slotdumpling.top/paint\";\r\n// BASE_URL = \"http://100.81.113.84:8090/paint\";\r\naxios.defaults.baseURL = BASE_URL;\r\n\r\naxios.interceptors.request.use((config) => {\r\n  console.log(config.method, config.url);\r\n  return config;\r\n});\r\n\r\nexport async function getNoteID(roomCode: number) {\r\n  try {\r\n    const { data } = await axios.get(`code/${roomCode}`);\r\n    console.log({ data });\r\n    if (data.statusCode !== 200) return null;\r\n    return data.noteID as string;\r\n  } catch (e) {\r\n    console.error(e);\r\n    return null;\r\n  }\r\n}\r\n\r\ninterface InfoRes {\r\n  statusCode: number;\r\n  code: number;\r\n  noteInfo: TeamNoteInfo;\r\n  pageInfos: Record<string, TeamPageInfo>;\r\n}\r\n\r\nexport async function getTeamNoteInfo(noteID: string) {\r\n  try {\r\n    const { data } = await axios.get(`info/${noteID}`);\r\n    const { statusCode, ...res } = data as InfoRes;\r\n    if (statusCode !== 200) return null;\r\n    return res;\r\n  } catch (e) {\r\n    console.error(e);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function loadTeamNoteInfo(noteID: string) {\r\n  try {\r\n    const infoRes = await getTeamNoteInfo(noteID);\r\n    if (!infoRes) return null;\r\n    const { noteInfo, pageInfos } = infoRes;\r\n\r\n    if (await updateTeamNote(noteID, noteInfo, pageInfos)) return infoRes;\r\n\r\n    let file: Blob | undefined = undefined;\r\n    if (noteInfo.withImg) {\r\n      const { data } = await axios({\r\n        method: \"GET\",\r\n        url: noteID,\r\n        responseType: \"blob\",\r\n      });\r\n      file = new Blob([data], { type: \"application/pdf\" });\r\n    }\r\n    await saveTeamNote(noteID, noteInfo, pageInfos, file);\r\n    return infoRes;\r\n  } catch (e) {\r\n    console.error(e);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function putNote(noteID: string) {\r\n  const note = await loadNote(noteID);\r\n  if (!note) return null;\r\n  const { uid, name, withImg, pdf, pageOrder, pageRec } = note;\r\n  removePageTimg(pageRec);\r\n\r\n  try {\r\n    const { data } = await axios.put(`create/${noteID}`, {\r\n      userID: getUserID(),\r\n      pageRec,\r\n      noteInfo: { uid, name, withImg, pageOrder },\r\n    });\r\n\r\n    if (pdf) {\r\n      const formData = new FormData();\r\n      const ab = await pdf.arrayBuffer();\r\n      const file = new Blob([ab]);\r\n      formData.append(\"file\", file, noteID);\r\n      await axios({\r\n        method: \"POST\",\r\n        url: \"upload\",\r\n        data: formData,\r\n        headers: { \"Content-Type\": \"multipart/form-data\" },\r\n      });\r\n    }\r\n\r\n    if (data.statusCode !== 201) return null;\r\n    return data.code as number;\r\n  } catch (e) {\r\n    console.error(e);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function updatePages(noteID: string) {\r\n  const note = await loadNote(noteID);\r\n  if (!note) return null;\r\n  const { uid, name, withImg, pageOrder, pageRec } = note;\r\n  removePageTimg(pageRec);\r\n  \r\n  try {\r\n    const { data } = await axios.put(`update/${noteID}`, {\r\n      userID: getUserID(),\r\n      pageRec,\r\n      noteInfo: { uid, name, withImg, pageOrder },\r\n    });\r\n    if (data.statusCode === 201) return true;\r\n    else return false;\r\n  } catch (e) {\r\n    console.error(e);\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function getTeamNoteState(noteID: string) {\r\n  try {\r\n    const { data } = await axios.get(`state/${noteID}`, {\r\n      params: { userID: getUserID() },\r\n    });\r\n    if (data.statusCode !== 200) return null;\r\n    const { teamPages } = data;\r\n    return teamPages as Record<string, TeamPage>;\r\n  } catch (e) {\r\n    console.error(e);\r\n    return null;\r\n  }\r\n}\r\n","import { Note, NoteInfo, NotePage, TeamNoteInfo, TeamPageInfo } from \"./note\";\r\nimport { getDefaultFlatState } from \"../draw/DrawState\";\r\nimport { getRandomColor } from \"../color\";\r\nimport localforage from \"localforage\";\r\nimport { v4 as getUid } from \"uuid\";\r\nimport { pickBy } from \"lodash-es\";\r\nimport moment from \"moment\";\r\n\r\nexport interface NoteTag {\r\n  uid: string;\r\n  name: string;\r\n  color: string;\r\n  notes: string[];\r\n}\r\n\r\nexport async function getAllNotes() {\r\n  const allNotes = await localforage.getItem(\"ALL_NOTES\");\r\n  if (allNotes) {\r\n    return allNotes as Record<string, NoteInfo>;\r\n  } else {\r\n    localforage.setItem(\"ALL_NOTES\", {});\r\n    return {};\r\n  }\r\n}\r\n\r\nexport async function getAllTags() {\r\n  const tags = await localforage.getItem(\"ALL_TAGS\");\r\n  if (tags) {\r\n    return tags as Record<string, NoteTag>;\r\n  } else {\r\n    localforage.setItem(\"ALL_TAGS\", {});\r\n    return {};\r\n  }\r\n}\r\n\r\nexport async function addNewTag(name: string) {\r\n  const uid = getUid();\r\n  const newTag: NoteTag = {\r\n    uid,\r\n    name,\r\n    color: getRandomColor(),\r\n    notes: [],\r\n  };\r\n  const prevTags = await getAllTags();\r\n  const tags = { ...prevTags, [uid]: newTag };\r\n  await localforage.setItem(\"ALL_TAGS\", tags);\r\n\r\n  return tags;\r\n}\r\n\r\nexport async function deleteTag(uid: string) {\r\n  const prevTags = await getAllTags();\r\n  const { [uid]: _, ...tags } = prevTags;\r\n  await localforage.setItem(\"ALL_TAGS\", tags);\r\n\r\n  return tags;\r\n}\r\n\r\nexport async function editTag(tag: NoteTag) {\r\n  const prevTags = await getAllTags();\r\n  const tags = { ...prevTags, [tag.uid]: tag };\r\n  await localforage.setItem(\"ALL_TAGS\", tags);\r\n  return tags;\r\n}\r\n\r\nexport async function loadNote(uid: string) {\r\n  const note = (await localforage.getItem(uid)) as Note | undefined;\r\n  if (!note) return;\r\n  const pdf = (await localforage.getItem(`PDF_${uid}`)) as Blob | undefined;\r\n  return { ...note, pdf };\r\n}\r\n\r\nexport async function editNoteData(uid: string, noteData: Partial<Note>) {\r\n  noteData = pickBy(noteData, (v) => v !== undefined);\r\n  if (\"pageRec\" in noteData) noteData.lastTime = moment.now();\r\n  console.dir(noteData);\r\n\r\n  const allNotes = await getAllNotes();\r\n  const { pageRec, pageOrder, ...noteInfo } = noteData;\r\n  allNotes[uid] = { ...allNotes[uid], ...noteInfo };\r\n\r\n  await localforage.setItem(\"ALL_NOTES\", allNotes);\r\n  const prevNote = await loadNote(uid);\r\n  if (!prevNote) return;\r\n  await localforage.setItem(uid, { ...prevNote, ...noteData });\r\n}\r\n\r\nexport async function saveNoteInfo(noteInfo: NoteInfo) {\r\n  const { uid, tagID } = noteInfo;\r\n  const allNotes = await getAllNotes();\r\n  allNotes[uid] = noteInfo;\r\n  await localforage.setItem(\"ALL_NOTES\", allNotes);\r\n  const tags = await getAllTags();\r\n  if (tagID !== \"DEFAULT\") {\r\n    tags[tagID].notes.push(noteInfo.uid);\r\n    await localforage.setItem(\"ALL_TAGS\", tags);\r\n  }\r\n  return { tags, allNotes };\r\n}\r\n\r\nexport async function createNewNote(noteWithPdf: Note) {\r\n  const { pdf, ...note } = noteWithPdf;\r\n  await localforage.setItem(note.uid, note);\r\n  if (pdf) await localforage.setItem(`PDF_${note.uid}`, pdf);\r\n  const { pageRec, pageOrder, ...noteInfo } = note;\r\n  return await saveNoteInfo(noteInfo);\r\n}\r\n\r\nexport async function deleteNote(uid: string) {\r\n  const note = await loadNote(uid);\r\n  const allNotes = await getAllNotes();\r\n  const tags = await getAllTags();\r\n  if (!note) return { tags, allNotes };\r\n  await localforage.removeItem(uid);\r\n  await localforage.removeItem(`PDF_${uid}`);\r\n  const { tagID } = note;\r\n  delete allNotes[uid];\r\n  await localforage.setItem(\"ALL_NOTES\", allNotes);\r\n\r\n  if (tagID !== \"DEFAULT\") {\r\n    const { notes } = tags[tagID];\r\n    tags[tagID].notes = notes.filter((id) => id !== uid);\r\n    await localforage.setItem(\"ALL_TAGS\", tags);\r\n  }\r\n  return { tags, allNotes };\r\n}\r\n\r\nexport async function moveNoteTag(noteID: string, tagID: string) {\r\n  const note = await loadNote(noteID);\r\n  const allNotes = await getAllNotes();\r\n  const tags = await getAllTags();\r\n  if (!note) return { tags, allNotes };\r\n\r\n  const { tagID: prevTagId } = note;\r\n  note.tagID = tagID;\r\n  await localforage.setItem(noteID, note);\r\n  allNotes[noteID].tagID = tagID;\r\n  await localforage.setItem(\"ALL_NOTES\", allNotes);\r\n\r\n  if (prevTagId in tags) {\r\n    tags[prevTagId].notes = tags[prevTagId].notes.filter((id) => id !== noteID);\r\n  }\r\n  tags[tagID]?.notes?.push(noteID);\r\n  await localforage.setItem(\"ALL_TAGS\", tags);\r\n  return { tags, allNotes };\r\n}\r\n\r\nexport async function saveTeamNote(\r\n  noteID: string,\r\n  noteInfo: TeamNoteInfo,\r\n  teamPages: Record<string, TeamPageInfo>,\r\n  file?: Blob\r\n) {\r\n  let note = await loadNote(noteID);\r\n  if (note) return;\r\n  const time = moment.now();\r\n  const pageRec: Record<string, NotePage> = {};\r\n  note = {\r\n    ...noteInfo,\r\n    tagID: \"DEFAULT\",\r\n    team: true,\r\n    pageRec,\r\n    pdf: file,\r\n    createTime: time,\r\n    lastTime: time,\r\n  };\r\n\r\n  // set empty state for each page\r\n  Object.entries(teamPages).forEach(([pageID, page]) => {\r\n    pageRec[pageID] = { ...page, state: getDefaultFlatState() };\r\n  });\r\n\r\n  // parse timg for each page\r\n  if (file) {\r\n    const { getPDFImages } = await import(\"../note/pdfImage\");\r\n    const { images } = await getPDFImages(file);\r\n    Object.values(pageRec).forEach((page) => {\r\n      const { pdfIndex } = page;\r\n      if (!pdfIndex) return;\r\n      page.image = images[pdfIndex - 1];\r\n    });\r\n    note.thumbnail = images[0];\r\n  }\r\n\r\n  await createNewNote(note);\r\n}\r\n\r\nexport async function updateTeamNote(\r\n  noteID: string,\r\n  noteInfo: TeamNoteInfo,\r\n  pageInfos: Record<string, TeamPageInfo>\r\n) {\r\n  let note = await loadNote(noteID);\r\n  if (!note) return false;\r\n  const { pageOrder } = noteInfo;\r\n  if (pageOrder.length < note.pageOrder.length) return true;\r\n  const { pageRec, pdf } = note;\r\n  const { getOneImage } = await import(\"./pdfImage\");\r\n\r\n  // parse timgs & set empty states for new pages.\r\n  for (let [pageID, page] of Object.entries(pageInfos)) {\r\n    if (pageID in pageRec) continue;\r\n    const { pdfIndex } = page;\r\n    const state = getDefaultFlatState();\r\n    pageRec[pageID] = { ...page, state };\r\n    if (!pdf || !pdfIndex) continue;\r\n    pageRec[pageID].image = await getOneImage(pdf, pdfIndex, 0.5);\r\n  }\r\n  await editNoteData(noteID, { pageOrder, pageRec });\r\n  return true;\r\n}\r\n","import { getDefaultFlatState, FlatState } from \"../draw/DrawState\";\r\nimport { v4 as getUid } from \"uuid\";\r\nimport moment from \"moment\";\r\n\r\nexport interface NotePage {\r\n  ratio: number;\r\n  state: FlatState;\r\n  image?: string;\r\n  marked?: boolean;\r\n  pdfIndex?: number;\r\n}\r\n\r\nexport const defaultNotePage: Readonly<NotePage> = {\r\n  ratio: 1.5,\r\n  state: { strokes: {} },\r\n};\r\n\r\nexport interface TeamPageState {\r\n  states: Record<string, FlatState>;\r\n}\r\n\r\nexport interface TeamPageInfo {\r\n  ratio: number;\r\n  pdfIndex?: number;\r\n}\r\n\r\nexport type TeamPage = TeamPageInfo & TeamPageState;\r\n\r\nexport interface TeamNote {\r\n  uid: string;\r\n  pageRec: Record<string, TeamPage>;\r\n}\r\n\r\nexport interface NoteInfo {\r\n  uid: string;\r\n  name: string;\r\n  tagID: string;\r\n  team: boolean;\r\n  withImg: boolean;\r\n  createTime: number;\r\n  lastTime: number;\r\n  thumbnail?: string;\r\n}\r\n\r\nexport type Note = NoteInfo & {\r\n  pdf?: Blob;\r\n  pageRec: Record<string, NotePage>;\r\n  pageOrder: string[];\r\n};\r\n\r\nexport interface TeamNoteInfo {\r\n  uid: string;\r\n  name: string;\r\n  pageOrder: string[];\r\n  withImg: boolean;\r\n}\r\n\r\nexport function createEmptyNote(): Note {\r\n  const pageID = getUid();\r\n  const time = moment.now();\r\n  return {\r\n    uid: getUid(),\r\n    name: `Note ${moment(time).format(\"LT, ddd MMM D\")}`,\r\n    tagID: \"DEFAULT\",\r\n    team: false,\r\n    withImg: false,\r\n    createTime: time,\r\n    lastTime: time,\r\n    pageRec: {\r\n      [pageID]: {\r\n        ratio: 1.5,\r\n        state: getDefaultFlatState(),\r\n      },\r\n    },\r\n    pageOrder: [pageID],\r\n  };\r\n}\r\n\r\nexport function createPage(page?: NotePage): [string, NotePage] {\r\n  const pageID = getUid();\r\n  const newPage = page ?? {\r\n    ratio: 1.5,\r\n    state: getDefaultFlatState(),\r\n  };\r\n  return [pageID, newPage];\r\n}\r\n\r\nexport function removePageTimg(pageRec: Record<string, NotePage>) {\r\n  Object.values(pageRec).forEach((page) => {\r\n    delete page.image;\r\n    delete page.marked;\r\n  });\r\n}\r\n","import { v4 as getUid } from \"uuid\";\r\n\r\nexport interface UserInfo {\r\n  userID: string;\r\n  userName: string;\r\n  online: boolean;\r\n}\r\n\r\nexport const getUserID = (() => {\r\n  let cached: string;\r\n  return () => {\r\n    if (cached) return cached;\r\n    let userID = localStorage.getItem(\"USER_ID\");\r\n    if (!userID) {\r\n      userID = getUid();\r\n      localStorage.setItem(\"USER_ID\", userID);\r\n    }\r\n    cached = userID;\r\n    return userID;\r\n  };\r\n})();\r\n\r\nexport const getUserName = () => {\r\n  let name = localStorage.getItem(\"USER_NAME\");\r\n  if (!name) {\r\n    name = getUid().slice(0, 8);\r\n    localStorage.setItem(\"USER_NAME\", name);\r\n  }\r\n  return name;\r\n};\r\n\r\nexport const saveUserName = (name: string) => {\r\n  name = name.trim();\r\n  if (!name) return false;\r\n  else localStorage.setItem(\"USER_NAME\", name);\r\n  return true;\r\n};\r\n"],"names":["colors","getRandomColor","index","Math","floor","random","length","getHashedColor","str","hash","i","charCodeAt","abs","hashCode","WIDTH","defaultRecord","strokes","OrderedMap","undoStack","List","historyStack","defaultFactory","Record","getDefaultFlatState","DrawState","immutable","width","height","lastOp","this","getImmutable","get","getStrokeMap","toArray","map","last","size","uid","has","drawState","lastRecord","getHistoryStack","getUndoStack","unshift","set","type","nextRecord","first","pathData","stroke","getUid","timestamp","Date","now","pushStroke","prevRecord","currRecord","update","s","push","delete","erased","m","deleteAll","mutations","forEach","prevStroke","op","eraseStrokes","mutateStrokes","undo","redo","toObject","flatState","operations","ds","pushOperation","states","iterators","values","mergedStrokes","heap","Heap","s0","s1","iter","next","value","done","record","pop","BASE_URL","getNoteID","roomCode","axios","data","console","log","statusCode","noteID","error","getTeamNoteInfo","res","loadTeamNoteInfo","infoRes","noteInfo","pageInfos","updateTeamNote","file","undefined","withImg","method","url","responseType","Blob","saveTeamNote","putNote","loadNote","note","name","pdf","pageOrder","pageRec","removePageTimg","userID","getUserID","formData","FormData","arrayBuffer","ab","append","headers","code","updatePages","getTeamNoteState","params","teamPages","config","getAllNotes","localforage","allNotes","getAllTags","tags","addNewTag","newTag","color","notes","prevTags","deleteTag","editTag","tag","editNoteData","noteData","pickBy","v","lastTime","moment","dir","prevNote","saveNoteInfo","tagID","createNewNote","noteWithPdf","deleteNote","filter","id","moveNoteTag","prevTagId","time","team","createTime","Object","entries","pageID","page","state","getPDFImages","images","pdfIndex","image","thumbnail","getOneImage","defaultNotePage","ratio","createEmptyNote","format","createPage","marked","cached","localStorage","getItem","setItem","getUserName","slice","saveUserName","trim"],"sourceRoot":""}