{"version":3,"file":"static/js/542.cff4642a.chunk.js","mappings":"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","sources":["component/ColorCircle/ColorCircle.tsx","lib/color.ts","lib/draw/DrawState.ts","lib/draw/TeamState.ts","lib/hooks.tsx","lib/network/http.ts","lib/note/archive.ts","lib/note/note.ts","lib/user.ts"],"sourcesContent":["import classNames from \"classnames\";\nimport { FC } from \"react\";\n\nexport const ColorCirle: FC<{ color: string; className?: string }> = ({\n  color,\n  className,\n}) => {\n  const style = { backgroundColor: color };\n  return (\n    <div className={classNames(\"color-circle\", className)} style={style} />\n  );\n};\n","import { CSSProperties } from \"react\";\nimport hash from \"string-hash\";\nexport const colors = [\n  \"#f97316\",\n  \"#eab308\",\n  \"#84cc16\",\n  \"#22c55e\",\n  \"#10b981\",\n  \"#14b8a6\",\n  \"#06b6d4\",\n  \"#0ea5e9\",\n  \"#3b82f6\",\n  \"#6366f1\",\n  \"#8b5cf6\",\n  \"#a855f7\",\n  \"#d946ef\",\n  \"#ec4899\",\n  \"#f43f5e\",\n  \"#ef4444\",\n];\n\nexport const grayColors = [\"#000000\", \"#9ca3af\", \"#64748b\", \"#78716c\"];\nexport const allColors = [...grayColors, ...colors];\n\nexport const getRandomColor = () => {\n  const index = Math.floor(Math.random() * colors.length);\n  return colors[index]!;\n};\n\nexport const getHashedColor = (str: string) => {\n  const index = hash(str) % colors.length;\n  return colors[index];\n};\n\nconst colorPalette: Record<string, { light: string; dark: string }> = {\n  \"#f97316\": { light: \"#FFEDD5\", dark: \"#9A3412\" },\n  \"#eab308\": { light: \"#FEF9C3\", dark: \"#854D0E\" },\n  \"#84cc16\": { light: \"#ECFCCB\", dark: \"#3F6212\" },\n  \"#22c55e\": { light: \"#DCFCE7\", dark: \"#166534\" },\n  \"#10b981\": { light: \"#D1FAE5\", dark: \"#065F46\" },\n  \"#14b8a6\": { light: \"#CCFBF1\", dark: \"#115E59\" },\n  \"#06b6d4\": { light: \"#CFFAFE\", dark: \"#155E75\" },\n  \"#0ea5e9\": { light: \"#E0F2FE\", dark: \"#075985\" },\n  \"#3b82f6\": { light: \"#DBEAFE\", dark: \"#1E40AF\" },\n  \"#6366f1\": { light: \"#E0E7FF\", dark: \"#3730A3\" },\n  \"#8b5cf6\": { light: \"#EDE9FE\", dark: \"#5B21B6\" },\n  \"#a855f7\": { light: \"#F3E8FF\", dark: \"#6B21A8\" },\n  \"#d946ef\": { light: \"#FAE8FF\", dark: \"#86198F\" },\n  \"#ec4899\": { light: \"#FCE7F3\", dark: \"#9D174D\" },\n  \"#f43f5e\": { light: \"#FFE4E6\", dark: \"#9F1239\" },\n  \"#ef4444\": { light: \"#FEE2E2\", dark: \"#991B1B\" },\n};\n\nexport const getColorPalette = (color: string) => {\n  const palette = colorPalette[color] ?? { light: \"#E5E7EB\", dark: \"#374151\" };\n  return {\n    \"--light-color\": palette.light,\n    \"--dark-color\": palette.dark,\n  } as CSSProperties;\n};\n","import { List, Record, OrderedMap, Map } from \"immutable\";\nimport { NIL, v4, v5, validate } from \"uuid\";\nimport Heap from \"heap\";\n\nexport const WIDTH = 2000;\n\nexport interface Stroke {\n  type: \"STROKE\";\n  uid: string;\n  pathData: string;\n  timestamp: number;\n}\n\nexport type StrokeData =\n  | Stroke\n  | {\n      type: \"HIDE\";\n      uid: string;\n      originUid: string;\n      timestamp: number;\n    }\n  | {\n      type: \"MUTATE\";\n      uid: string;\n      originUid: string;\n      pathData: string;\n      timestamp: number;\n    };\n\nexport type StrokeRecord = globalThis.Record<string, StrokeData>;\nexport type Mutation = [string, string];\nexport type Splitter = [string, string[]];\n\nexport type Operation =\n  | {\n      type: \"add\";\n      stroke: Stroke;\n    }\n  | {\n      type: \"add_list\";\n      strokeList: Stroke[];\n    }\n  | {\n      type: \"erase\";\n      erased: string[];\n    }\n  | {\n      type: \"mutate\";\n      mutations: Mutation[];\n    }\n  | {\n      type: \"split\";\n      splitters: Splitter[];\n    }\n  | {\n      type: \"undo\";\n    }\n  | {\n      type: \"redo\";\n    };\n\ninterface DrawStateRecordType {\n  strokes: OrderedMap<string, StrokeData>;\n  mutationPairs: Map<string, string>; //{ [originID]: [mutationID] }\n  undoStack: List<DrawStateRecord>;\n  historyStack: List<DrawStateRecord>;\n}\n\ntype DrawStateRecord = Record<DrawStateRecordType>;\n\nconst defaultRecord: Readonly<DrawStateRecordType> = {\n  strokes: OrderedMap(),\n  mutationPairs: Map(),\n  undoStack: List(),\n  historyStack: List(),\n};\n\nconst defaultFactory = Record(defaultRecord);\n\nexport interface FlatState {\n  strokes: StrokeRecord;\n  operations?: Operation[];\n}\n\nexport const getDefaultFlatState = (): FlatState => {\n  return { strokes: {} };\n};\n\nexport class DrawState {\n  constructor(\n    private immutable: DrawStateRecord,\n    public readonly width: number,\n    public readonly height: number,\n    public lastOp?: Operation\n  ) {}\n\n  getImmutable() {\n    return this.immutable;\n  }\n\n  getUndoStack() {\n    return this.getImmutable().get(\"undoStack\");\n  }\n\n  getHistoryStack() {\n    return this.getImmutable().get(\"historyStack\");\n  }\n\n  getStrokeMap() {\n    return this.getImmutable().get(\"strokes\");\n  }\n\n  getLastStroke() {\n    return this.getStrokeMap().last();\n  }\n\n  getMutationPairs() {\n    return this.getImmutable().get(\"mutationPairs\");\n  }\n\n  isEmpty() {\n    return this.getStrokeMap().size === 0;\n  }\n\n  hasStroke(uid: string) {\n    return this.getStrokeMap().has(uid);\n  }\n\n  static createEmpty(ratio: number, width = WIDTH) {\n    return new DrawState(defaultFactory(), width, width * ratio);\n  }\n\n  static undo(drawState: DrawState) {\n    const lastOp: Operation = { type: \"undo\" };\n    const lastRecord = drawState.getHistoryStack().last();\n    if (!lastRecord) return drawState;\n    const undoStack = drawState\n      .getUndoStack()\n      .unshift(drawState.getImmutable());\n    return new DrawState(\n      lastRecord.set(\"undoStack\", undoStack),\n      drawState.width,\n      drawState.height,\n      lastOp\n    );\n  }\n\n  static redo(drawState: DrawState) {\n    const lastOp: Operation = { type: \"redo\" };\n\n    const nextRecord = drawState.getUndoStack().first();\n    if (!nextRecord) return drawState;\n    return new DrawState(nextRecord, drawState.width, drawState.height, lastOp);\n  }\n\n  static addStroke(drawState: DrawState, pathData: string) {\n    const uid = v4();\n    const timestamp = Date.now();\n    const stroke: Stroke = { pathData, uid, timestamp, type: \"STROKE\" };\n    return DrawState.pushStroke(drawState, stroke);\n  }\n\n  static addStrokeList(\n    drawState: DrawState,\n    pathDataList: string[],\n    callback?: (IDs: string[]) => void\n  ) {\n    const newIDs: string[] = [];\n    const timestamp = Date.now();\n    const strokeList: Stroke[] = pathDataList.map((pathData) => {\n      const uid = v4();\n      newIDs.push(uid);\n      return { type: \"STROKE\", pathData, timestamp, uid };\n    });\n    callback?.(newIDs);\n\n    return DrawState.pushStrokeList(drawState, strokeList);\n  }\n\n  static pushStroke(drawState: DrawState, stroke: Stroke) {\n    const { uid } = stroke;\n    const prevRecord = drawState.getImmutable();\n    const currRecord = prevRecord\n      .update(\"strokes\", (s) => s.set(uid, stroke))\n      .update(\"historyStack\", (s) => s.push(prevRecord))\n      .delete(\"undoStack\");\n\n    const lastOp: Operation = { type: \"add\", stroke };\n\n    return new DrawState(currRecord, drawState.width, drawState.height, lastOp);\n  }\n\n  static pushStrokeList(drawState: DrawState, strokeList: Stroke[]) {\n    const prevRecord = drawState.getImmutable();\n    const currRecord = prevRecord.update(\"strokes\", (s) =>\n      s.merge(strokeList.map((stroke) => [stroke.uid, stroke]))\n    );\n    const lastOp: Operation = { type: \"add_list\", strokeList };\n\n    return new DrawState(currRecord, drawState.width, drawState.height, lastOp);\n  }\n\n  static eraseStrokes(drawState: DrawState, erased: string[]) {\n    if (erased.length === 0) return drawState;\n    const prevRecord = drawState.getImmutable();\n    let strokes = drawState.getStrokeMap();\n    const hidden = erased.filter((uid) => !strokes.has(uid));\n    strokes = strokes.deleteAll(erased);\n    hidden.forEach((hideID) => {\n      const uid = v4();\n      strokes = strokes.set(uid, {\n        type: \"HIDE\",\n        uid,\n        originUid: hideID,\n        timestamp: Date.now(),\n      });\n    });\n\n    const currRecord = prevRecord\n      .set(\"strokes\", strokes)\n      .update(\"historyStack\", (s) => s.push(prevRecord))\n      .delete(\"undoStack\");\n\n    const lastOp: Operation = { type: \"erase\", erased };\n\n    return new DrawState(currRecord, drawState.width, drawState.height, lastOp);\n  }\n\n  static mutateStrokes(drawState: DrawState, mutations: Mutation[]) {\n    if (mutations.length === 0) return drawState;\n    const prevRecord = drawState.getImmutable();\n    let strokes = drawState.getStrokeMap();\n    let mutationPairs = drawState.getMutationPairs();\n    mutations.forEach(([uid, pathData]) => {\n      const newUid = v4();\n      strokes = strokes.set(newUid, {\n        type: \"MUTATE\",\n        uid: newUid,\n        originUid: uid,\n        pathData,\n        timestamp: Date.now(),\n      });\n      const prevMutationUid = mutationPairs.get(uid);\n      mutationPairs = mutationPairs.set(uid, newUid);\n      strokes = strokes.delete(prevMutationUid ?? \"\");\n    });\n    const currRecord = prevRecord\n      .set(\"strokes\", strokes)\n      .set(\"mutationPairs\", mutationPairs)\n      .update(\"historyStack\", (s) => s.push(prevRecord))\n      .delete(\"undoStack\");\n\n    const lastOp: Operation = { type: \"mutate\", mutations };\n\n    return new DrawState(currRecord, drawState.width, drawState.height, lastOp);\n  }\n\n  static splitStrokes(drawState: DrawState, splitters: Splitter[]) {\n    if (splitters.length === 0) return drawState;\n    const splitMap = Map(splitters);\n    let strokes = OrderedMap<string, StrokeData>();\n    const prevStrokes = drawState.getStrokeMap();\n    prevStrokes.forEach((stroke, prevUid) => {\n      const splitStrokes = splitMap.get(prevUid);\n      if (splitStrokes) {\n        strokes = strokes.merge(\n          splitStrokes.map((pathData, index) => {\n            // update legacy uid solution.\n            if (!validate(prevUid)) prevUid = v5(prevUid, NIL);\n\n            const uid = v5(String(index), prevUid);\n            const { timestamp } = stroke;\n            return [uid, { pathData, timestamp, uid, type: \"STROKE\" }];\n          })\n        );\n      } else {\n        strokes = strokes.set(prevUid, stroke);\n      }\n    });\n    const prevRecord = drawState.getImmutable();\n    const currRecord = prevRecord\n      .set(\"strokes\", strokes)\n      .update(\"historyStack\", (s) => s.push(prevRecord));\n    const lastOp: Operation = { type: \"split\", splitters };\n    return new DrawState(currRecord, drawState.width, drawState.height, lastOp);\n  }\n\n  // sync with mutation.\n  static syncStrokeTime(drawState: DrawState, uid: string, timestamp: number) {\n    const prevStroke = drawState.getStrokeMap().get(uid);\n    if (!prevStroke) return;\n    prevStroke.timestamp = timestamp;\n  }\n\n  static pushOperation(drawState: DrawState, op: Operation) {\n    switch (op.type) {\n      case \"add\":\n        return DrawState.pushStroke(drawState, op.stroke);\n      case \"add_list\":\n        return DrawState.pushStrokeList(drawState, op.strokeList);\n      case \"erase\":\n        return DrawState.eraseStrokes(drawState, op.erased);\n      case \"mutate\":\n        return DrawState.mutateStrokes(drawState, op.mutations);\n      case \"undo\":\n        return DrawState.undo(drawState);\n      case \"redo\":\n        return DrawState.redo(drawState);\n      case \"split\":\n        return DrawState.splitStrokes(drawState, op.splitters);\n      default:\n        return drawState;\n    }\n  }\n\n  static flaten(drawState: DrawState): FlatState {\n    const strokes = drawState.getImmutable().get(\"strokes\").toObject();\n    return { strokes };\n  }\n\n  static loadFromFlat(\n    flatState: FlatState,\n    ratio: number,\n    width = WIDTH\n  ): DrawState {\n    const { strokes, operations } = flatState;\n    let strokeMap = OrderedMap(strokes);\n    let mutationPairs = Map<string, string>();\n\n    Object.entries(strokes).forEach(([uid, strokeData]) => {\n      if (strokeData.type !== \"MUTATE\") return;\n      const prevMutationUid = mutationPairs.get(strokeData.originUid);\n      mutationPairs = mutationPairs.set(strokeData.originUid, uid);\n      if (prevMutationUid) strokeMap = strokeMap.delete(prevMutationUid);\n    });\n\n    let ds = new DrawState(\n      defaultFactory()\n        .set(\"strokes\", strokeMap)\n        .set(\"mutationPairs\", mutationPairs),\n      width,\n      width * ratio\n    );\n    operations?.forEach((op) => (ds = DrawState.pushOperation(ds, op)));\n    return ds;\n  }\n\n  static mergeStates(...states: DrawState[]) {\n    const iterators = states.map((ds) => ds.getStrokeMap().values());\n    let mergedStrokes = OrderedMap<string, Stroke>();\n    const heap = new Heap<[StrokeData, number]>(\n      ([s0], [s1]) => s0.timestamp - s1.timestamp\n    );\n\n    iterators.forEach((iter, index) => {\n      const { value, done } = iter.next();\n      done || heap.push([value, index]);\n    });\n\n    while (heap.size() > 0) {\n      const record = heap.pop();\n      if (!record) break;\n      const [stroke, index] = record;\n\n      if (stroke.type === \"HIDE\") {\n        mergedStrokes = mergedStrokes.delete(stroke.originUid);\n      } else if (stroke.type === \"MUTATE\") {\n        const { originUid, pathData } = stroke;\n        mergedStrokes = mergedStrokes.update(\n          originUid,\n          (s) => s! && { ...s, pathData }\n        );\n      } else if (/^HIDE_/.test(stroke.pathData)) {\n        // temporary fallback, delete this later.\n        const hideID = stroke.pathData.slice(5);\n        mergedStrokes = mergedStrokes.delete(hideID);\n      } else {\n        const { uid } = stroke;\n        mergedStrokes = mergedStrokes.set(uid, stroke);\n      }\n\n      const iterator = iterators[index];\n      if (!iterator) break;\n      const { value, done } = iterator.next();\n      done || heap.push([value, index]);\n    }\n    return mergedStrokes;\n  }\n}\n","import { NotePage, TeamPageInfo, TeamPageRec } from \"lib/note/note\";\nimport { DrawState } from \"./DrawState\";\nimport { SetOperation } from \"./StateSet\";\nimport { Map, Record, Set } from \"immutable\";\n\ninterface TeamStateRecordType {\n  pageStates: Map<string, Map<string, DrawState>>;\n  pageInfos: Map<string, TeamPageInfo>;\n}\n\nconst defaultRecord: Readonly<TeamStateRecordType> = {\n  pageStates: Map(),\n  pageInfos: Map(),\n};\n\ntype TeamStateRecord = Record<TeamStateRecordType>;\nconst defaultFactory = Record(defaultRecord);\n\nexport class TeamState {\n  constructor(private immutable: TeamStateRecord) {}\n\n  getImmutable() {\n    return this.immutable;\n  }\n\n  getPageStates() {\n    return this.getImmutable().get(\"pageStates\");\n  }\n\n  getPageInfos() {\n    return this.getImmutable().get(\"pageInfos\");\n  }\n\n  getOneState(pageID: string, userID: string) {\n    return this.getPageStates().get(pageID)?.get(userID);\n  }\n\n  getOnePageStateMap(pageID: string) {\n    return this.getPageStates().get(pageID);\n  }\n\n  getPageRatio(pageID: string) {\n    return this.getPageInfos().get(pageID)?.ratio;\n  }\n\n  includesPage(pageID: string) {\n    return this.getPageStates().has(pageID);\n  }\n\n  setState(pageID: string, userID: string, drawState: DrawState) {\n    const pageMap = this.getPageStates().get(pageID);\n    if (!pageMap) return this;\n    return new TeamState(\n      this.getImmutable().update(\"pageStates\", (m) =>\n        m.set(pageID, pageMap.set(userID, drawState))\n      )\n    );\n  }\n\n  static createFromTeamPages(teamPages: TeamPageRec) {\n    let record = defaultFactory();\n    Object.entries(teamPages).forEach(([pageID, teamPage]) => {\n      const { states, ratio } = teamPage;\n      const pageMap = Map(\n        Object.entries(states).map(([userID, flatState]) => [\n          userID,\n          DrawState.loadFromFlat(flatState, ratio),\n        ])\n      );\n      record = record\n        .update(\"pageStates\", (m) => m.set(pageID, pageMap))\n        .update(\"pageInfos\", (m) => m.set(pageID, { ratio }));\n    });\n    return new TeamState(record);\n  }\n\n  addPage(pageID: string, notePage: NotePage) {\n    const { ratio } = notePage;\n    return new TeamState(\n      this.getImmutable()\n        .update(\"pageStates\", (m) => m.set(pageID, Map()))\n        .update(\"pageInfos\", (m) => m.set(pageID, { ratio }))\n    );\n  }\n\n  pushOperation(setOp: SetOperation, userID: string) {\n    const { pageID, ...op } = setOp;\n    const ratio = this.getPageRatio(pageID);\n    if (!this.includesPage(pageID) || !ratio) return this;\n    const prevDs =\n      this.getOneState(pageID, userID) || DrawState.createEmpty(ratio);\n\n    const ds = DrawState.pushOperation(prevDs, op);\n    return this.setState(pageID, userID, ds);\n  }\n\n  resetUser(userID: string, pageRec: globalThis.Record<string, NotePage>) {\n    let newTS: TeamState = this;\n    for (let [pageID, { state, ratio }] of Object.entries(pageRec)) {\n      const prevDS = newTS.getOneState(pageID, userID);\n      if (!prevDS) continue;\n      newTS = newTS.setState(\n        pageID,\n        userID,\n        DrawState.loadFromFlat(state, ratio)\n      );\n    }\n    return newTS;\n  }\n\n  static getValidUsers(\n    teamStateMap?: Map<string, DrawState>,\n    ignores = Set<string>()\n  ) {\n    if (!teamStateMap) return [];\n    return Array.from(\n      teamStateMap\n        .filter((ds) => !ds.isEmpty())\n        .deleteAll(ignores)\n        .keys()\n    );\n  }\n  static isEmpty(teamStateMap?: Map<string, DrawState>) {\n    return !teamStateMap || teamStateMap.every((ds) => ds.isEmpty());\n  }\n}\n","import React, {\n  createContext,\n  Dispatch,\n  FC,\n  PropsWithChildren,\n  SetStateAction,\n  TransitionEventHandler,\n  useContext,\n  useDebugValue,\n  useRef,\n  useState,\n} from \"react\";\n\nexport type Setter<T> = Dispatch<SetStateAction<T>>;\n\nexport function useTransitionEnd({\n  propertyName,\n  active = true,\n}: {\n  propertyName: string;\n  active?: boolean;\n}): [Promise<void>, TransitionEventHandler] {\n  const resRef = useRef(() => {});\n  const [promise] = useState(\n    () => new Promise<void>((res) => (resRef.current = res))\n  );\n  return [\n    promise,\n    (e) => {\n      if (e.propertyName === propertyName && active) resRef.current();\n    },\n  ];\n}\n\nconst ActiveKeyCtx = createContext<[string, Setter<string>]>([\"\", () => {}]);\nexport function useActiveKey() {\n  const tuple = useContext(ActiveKeyCtx);\n  useDebugValue(tuple[0]);\n  return tuple;\n}\n\nexport const ActiveKeyProvider: FC<PropsWithChildren<{ initKey: string }>> = ({\n  children,\n  initKey,\n}) => {\n  const tuple = useState(initKey);\n  return (\n    <ActiveKeyCtx.Provider value={tuple}>{children}</ActiveKeyCtx.Provider>\n  );\n};\n\nconst AsideOpenCtx = createContext<[boolean, Setter<boolean>]>([\n  false,\n  () => {},\n]);\nexport function useAsideOpen() {\n  const tuple = useContext(AsideOpenCtx);\n  useDebugValue(tuple[0]);\n  return tuple;\n}\n\nexport const AsideOpenProvider: FC<PropsWithChildren> = ({ children }) => {\n  const tuple = useState(false);\n  return (\n    <AsideOpenCtx.Provider value={tuple}>{children}</AsideOpenCtx.Provider>\n  );\n};\n","import axios from \"axios\";\nimport {\n  removePageTimg,\n  TeamNoteInfo,\n  TeamPageInfo,\n  TeamPageRec,\n} from \"lib/note/note\";\nimport { loadNote, saveTeamNote, updateTeamNote } from \"lib/note/archive\";\nimport { getUserID } from \"lib/user\";\nimport localforage from \"localforage\";\nimport md5 from \"md5\";\n\nexport const BASE_URL = process.env.REACT_APP_PUBLIC_SERVER_URL ?? \"\";\n// export const BASE_URL = process.env.REACT_APP_LOCAL_SERVER_URL ?? \"\";\naxios.defaults.baseURL = BASE_URL;\n\nexport async function getNoteID(roomCode: string) {\n  try {\n    const { data } = await axios.get(`code/${roomCode}`);\n    if (data.statusCode !== 200) return null;\n    return data.noteID as string;\n  } catch (e) {\n    console.error(e);\n    return null;\n  }\n}\n\ninterface InfoRes {\n  statusCode: number;\n  code: number;\n  noteInfo: TeamNoteInfo;\n  pageInfos: Record<string, TeamPageInfo>;\n}\n\nexport async function getTeamNoteInfo(noteID: string) {\n  try {\n    const { data } = await axios.get(`info/${noteID}`);\n    const { statusCode, ...res } = data as InfoRes;\n    if (statusCode !== 200) return null;\n    return res;\n  } catch (e) {\n    console.error(e);\n    return null;\n  }\n}\n\nexport async function loadTeamNoteInfo(\n  noteID: string,\n  cb?: (len: number) => void\n) {\n  try {\n    const infoRes = await getTeamNoteInfo(noteID);\n    if (!infoRes) return null;\n    const { noteInfo, pageInfos } = infoRes;\n\n    if (await updateTeamNote(noteID, noteInfo, pageInfos)) return infoRes;\n\n    if (noteInfo.withImg) {\n      const { data } = await axios({\n        method: \"GET\",\n        url: noteID,\n        responseType: \"blob\",\n        onDownloadProgress({ loaded }: ProgressEvent) {\n          cb?.(loaded);\n        },\n      });\n      const file = new Blob([data], { type: \"application/pdf\" });\n      await saveTeamNote(noteID, noteInfo, pageInfos, file);\n    } else {\n      await saveTeamNote(noteID, noteInfo, pageInfos);\n    }\n    return infoRes;\n  } catch (e) {\n    console.error(e);\n    return null;\n  }\n}\n\nexport async function putNote(noteID: string) {\n  const note = await loadNote(noteID);\n  if (!note) return false;\n  const { uid, name, withImg, pdf, pageOrder, pageRec } = note;\n  removePageTimg(pageRec);\n\n  try {\n    const { data } = await axios.put(`create/${noteID}`, {\n      userID: getUserID(),\n      pageRec,\n      noteInfo: { uid, name, withImg, pageOrder },\n    });\n\n    if (pdf) {\n      const formData = new FormData();\n      const ab = await pdf.arrayBuffer();\n      const file = new Blob([ab]);\n      formData.append(\"file\", file, noteID);\n      await axios({\n        method: \"POST\",\n        url: \"upload\",\n        data: formData,\n        headers: { \"Content-Type\": \"multipart/form-data\" },\n      });\n    }\n\n    if (data.statusCode !== 201) return false;\n    return true;\n  } catch (e) {\n    console.error(e);\n    return false;\n  }\n}\n\nconst hashForage = localforage.createInstance({ name: \"updateHash\" });\nexport async function updatePages(noteID: string) {\n  const note = await loadNote(noteID);\n  if (!note) return null;\n  const { uid, name, withImg, pageOrder, pageRec } = note;\n  removePageTimg(pageRec);\n  const noteInfo = { uid, name, withImg, pageOrder };\n\n  const hash = md5(JSON.stringify([pageRec, noteInfo]));\n  const lastHash = await hashForage.getItem<string>(noteID);\n  if (hash === lastHash) return true;\n\n  try {\n    const body = { userID: getUserID(), pageRec, noteInfo };\n    const { data } = await axios.put(`update/${noteID}`, body);\n    if (data.statusCode !== 201) return false;\n    await hashForage.setItem(noteID, hash);\n    return true;\n  } catch (e) {\n    console.error(e);\n    return false;\n  }\n}\n\nconst teamForage = localforage.createInstance({ name: \"teamState\" });\nexport async function getTeamNoteState(\n  noteID: string,\n  cb?: (len: number) => void\n) {\n  const cachedState = await loadCachedTeamState(noteID);\n  const hash = cachedState && md5(JSON.stringify(cachedState));\n\n  try {\n    const { data } = await axios.get(`state/${noteID}`, {\n      params: { userID: getUserID(), hash },\n      onDownloadProgress({ loaded }: ProgressEvent) {\n        cb?.(loaded);\n      },\n    });\n    const { statusCode, modified, teamPages } = data;\n    if (statusCode === 200 && modified) {\n      await teamForage.setItem(noteID, teamPages);\n      return teamPages as TeamPageRec;\n    }\n    return cachedState;\n  } catch (e) {\n    console.error(e);\n    return cachedState;\n  }\n}\n\nexport async function loadCachedTeamState(noteID: string) {\n  return (await teamForage.getItem<TeamPageRec>(noteID)) ?? undefined;\n}\n","import { Note, NoteInfo, NotePage, TeamNoteInfo, TeamPageInfo } from \"./note\";\nimport { getDefaultFlatState } from \"lib/draw/DrawState\";\nimport localforage from \"localforage\";\nimport { v4 as getUid } from \"uuid\";\nimport { pickBy } from \"lodash\";\n\nexport interface NoteTag {\n  uid: string;\n  name: string;\n  color: string;\n  notes: string[];\n}\n\nexport async function getAllNotes() {\n  const allNotes = await localforage.getItem<Record<string, NoteInfo>>(\n    \"ALL_NOTES\"\n  );\n  if (allNotes) return allNotes;\n  localforage.setItem(\"ALL_NOTES\", {});\n  return {};\n}\n\nexport async function getAllTags() {\n  const tags = await localforage.getItem<Record<string, NoteTag>>(\"ALL_TAGS\");\n  if (tags) return tags;\n  localforage.setItem(\"ALL_TAGS\", {});\n  return {};\n}\n\nexport async function addNewTag(name: string, color: string) {\n  const uid = getUid();\n  const newTag: NoteTag = {\n    uid,\n    name,\n    color,\n    notes: [],\n  };\n  const prevTags = await getAllTags();\n  const tags = { ...prevTags, [uid]: newTag };\n  await localforage.setItem(\"ALL_TAGS\", tags);\n\n  return tags;\n}\n\nexport async function deleteTag(uid: string) {\n  const prevTags = await getAllTags();\n  const { [uid]: _, ...tags } = prevTags;\n  await localforage.setItem(\"ALL_TAGS\", tags);\n\n  return tags;\n}\n\nexport async function editTag(tag: NoteTag) {\n  const prevTags = await getAllTags();\n  const tags = { ...prevTags, [tag.uid]: tag };\n  await localforage.setItem(\"ALL_TAGS\", tags);\n  return tags;\n}\n\nexport async function loadNote(uid: string) {\n  const note = await localforage.getItem<Note>(uid);\n  if (!note) return;\n  const pdf = await localforage.getItem<Blob>(`PDF_${uid}`);\n  if (pdf) return { ...note, pdf };\n  else return note;\n}\n\nexport async function editNoteData(uid: string, noteData: Partial<Note>) {\n  noteData = pickBy(noteData, (v) => v !== undefined);\n  if (\"pageRec\" in noteData) noteData.lastTime = Date.now();\n\n  const allNotes = await getAllNotes();\n  const { pageRec, pageOrder, ...noteInfo } = noteData;\n  const prevNoteInfo = allNotes[uid];\n  if (!prevNoteInfo) return;\n  allNotes[uid] = { ...prevNoteInfo, ...noteInfo };\n\n  await localforage.setItem(\"ALL_NOTES\", allNotes);\n  const prevNote = await loadNote(uid);\n  if (!prevNote) return;\n  await localforage.setItem(uid, { ...prevNote, ...noteData });\n}\n\nexport async function saveNoteInfo(noteInfo: NoteInfo) {\n  const { uid, tagID } = noteInfo;\n  const allNotes = await getAllNotes();\n  allNotes[uid] = noteInfo;\n  await localforage.setItem(\"ALL_NOTES\", allNotes);\n  const tags = await getAllTags();\n  const tag = tags[tagID];\n  if (tag) {\n    tag.notes.push(noteInfo.uid);\n    await localforage.setItem(\"ALL_TAGS\", tags);\n  }\n  return { tags, allNotes };\n}\n\nexport async function createNewNote(noteWithPdf: Note) {\n  const { pdf, ...note } = noteWithPdf;\n  await localforage.setItem(note.uid, note);\n  if (pdf) await localforage.setItem(`PDF_${note.uid}`, pdf);\n  const { pageRec, pageOrder, ...noteInfo } = note;\n  return await saveNoteInfo(noteInfo);\n}\n\nexport async function deleteNote(uid: string) {\n  const note = await loadNote(uid);\n  const allNotes = await getAllNotes();\n  const tags = await getAllTags();\n  if (!note) return { tags, allNotes };\n  await localforage.removeItem(uid);\n  await localforage.removeItem(`PDF_${uid}`);\n  delete allNotes[uid];\n  await localforage.setItem(\"ALL_NOTES\", allNotes);\n\n  const { tagID } = note;\n  const prevTag = tags[tagID];\n  if (prevTag) {\n    prevTag.notes = prevTag.notes.filter((id) => id !== uid);\n    await localforage.setItem(\"ALL_TAGS\", tags);\n  }\n  return { tags, allNotes };\n}\n\nexport async function moveNoteTag(noteID: string, tagID: string) {\n  const note = await loadNote(noteID);\n  const allNotes = await getAllNotes();\n  const tags = await getAllTags();\n  const noteInfo = allNotes[noteID];\n  if (!note || !noteInfo) return { tags, allNotes };\n\n  const { tagID: prevTagId } = note;\n  note.tagID = tagID;\n  await localforage.setItem(noteID, note);\n  noteInfo.tagID = tagID;\n  await localforage.setItem(\"ALL_NOTES\", allNotes);\n\n  const prevTag = tags[prevTagId];\n  if (prevTag) {\n    prevTag.notes = prevTag.notes.filter((id) => id !== noteID);\n  }\n  tags[tagID]?.notes.push(noteID);\n  await localforage.setItem(\"ALL_TAGS\", tags);\n  return { tags, allNotes };\n}\n\nexport async function saveTeamNote(\n  noteID: string,\n  noteInfo: TeamNoteInfo,\n  teamPages: Record<string, TeamPageInfo>,\n  file?: Blob\n) {\n  let note = await loadNote(noteID);\n  if (note) return;\n  const time = Date.now();\n  const pageRec: Record<string, NotePage> = {};\n  note = {\n    ...noteInfo,\n    tagID: \"DEFAULT\",\n    team: true,\n    pageRec,\n    pdf: file,\n    createTime: time,\n    lastTime: time,\n  };\n\n  // set empty state for each page\n  Object.entries(teamPages).forEach(([pageID, page]) => {\n    pageRec[pageID] = { ...page, state: getDefaultFlatState() };\n  });\n\n  // parse timg for each page\n  if (file) {\n    const { getPDFImages } = await import(\"./pdfImage\");\n    const { images } = await getPDFImages(file, 0.5);\n    Object.values(pageRec).forEach((page) => {\n      const { pdfIndex } = page;\n      if (!pdfIndex) return;\n      page.image = images[pdfIndex - 1];\n    });\n  }\n\n  await createNewNote(note);\n}\n\nexport async function updateTeamNote(\n  noteID: string,\n  noteInfo: TeamNoteInfo,\n  pageInfos: Record<string, TeamPageInfo>\n) {\n  let note = await loadNote(noteID);\n  if (!note) return false;\n  const { pageOrder } = noteInfo;\n  const { pageRec, pdf } = note;\n  const { getOneImage } = await import(\"./pdfImage\");\n\n  // parse timgs & set empty states for new pages.\n  for (let [pageID, teamPage] of Object.entries(pageInfos)) {\n    if (pageID in pageRec) continue;\n    const { pdfIndex } = teamPage;\n    const state = getDefaultFlatState();\n    const notePage: NotePage = { ...teamPage, state };\n    pageRec[pageID] = notePage;\n    if (pdf && pdfIndex) {\n      notePage.image = await getOneImage(pdf, pdfIndex, 0.5);\n    }\n  }\n  await editNoteData(noteID, { pageOrder, pageRec });\n  return true;\n}\n","import { getDefaultFlatState, FlatState } from \"lib/draw/DrawState\";\nimport { v4 as getUid } from \"uuid\";\nimport dayjs from \"dayjs\";\nexport interface NotePage {\n  ratio: number;\n  state: FlatState;\n  image?: string;\n  marked?: boolean;\n  pdfIndex?: number;\n}\n\nexport const defaultNotePage: Readonly<NotePage> = {\n  ratio: 1.5,\n  state: { strokes: {} },\n};\n\nexport interface TeamPageState {\n  states: Record<string, FlatState>;\n}\n\nexport interface TeamPageInfo {\n  ratio: number;\n  pdfIndex?: number;\n}\n\nexport type TeamPage = TeamPageInfo & TeamPageState;\nexport type TeamPageRec = Record<string, TeamPage>;\nexport interface TeamNote {\n  uid: string;\n  pageRec: TeamPageRec;\n}\n\nexport interface NoteInfo {\n  uid: string;\n  name: string;\n  tagID: string;\n  team: boolean;\n  withImg: boolean;\n  createTime: number;\n  lastTime: number;\n}\n\nexport type Note = NoteInfo & {\n  pdf?: Blob;\n  pageRec: Record<string, NotePage>;\n  pageOrder: string[];\n};\n\nexport interface TeamNoteInfo {\n  uid: string;\n  name: string;\n  pageOrder: string[];\n  withImg: boolean;\n}\n\nexport function createEmptyNote(): Note {\n  const pageID = getUid();\n  const time = Date.now();\n  return {\n    uid: getUid(),\n    name: `Note ${dayjs(time).format(\"HH:mm, ddd MMM D\")}`,\n    tagID: \"DEFAULT\",\n    team: false,\n    withImg: false,\n    createTime: time,\n    lastTime: time,\n    pageRec: {\n      [pageID]: {\n        ratio: 1.5,\n        state: getDefaultFlatState(),\n      },\n    },\n    pageOrder: [pageID],\n  };\n}\n\nexport function createPage(page?: NotePage): [string, NotePage] {\n  const pageID = getUid();\n  const newPage = page ?? {\n    ratio: 1.5,\n    state: getDefaultFlatState(),\n  };\n  return [pageID, newPage];\n}\n\nexport function removePageTimg(pageRec: Record<string, NotePage>) {\n  Object.values(pageRec).forEach((page) => {\n    delete page.image;\n    delete page.marked;\n  });\n}\n","import { animals, colors, uniqueNamesGenerator } from \"unique-names-generator\";\nimport { v4 as getUid } from \"uuid\";\n\nexport interface UserInfo {\n  userID: string;\n  userName: string;\n  online: boolean;\n}\n\nexport const getUserID = (() => {\n  let cached: string;\n  return () => {\n    if (cached) return cached;\n    let userID = localStorage.getItem(\"USER_ID\");\n    if (!userID) {\n      userID = getUid();\n      localStorage.setItem(\"USER_ID\", userID);\n    }\n    cached = userID;\n    return userID;\n  };\n})();\n\nexport const getUserName = () => {\n  let name = localStorage.getItem(\"USER_NAME\");\n  if (!name) {\n    name = uniqueNamesGenerator({\n      dictionaries: [colors, animals],\n      style: \"capital\",\n    });\n    localStorage.setItem(\"USER_NAME\", name);\n  }\n  return name;\n};\n\nexport const saveUserName = (name: string) => {\n  name = name.trim();\n  if (!name) return false;\n  else localStorage.setItem(\"USER_NAME\", name);\n  return true;\n};\n"],"names":["ColorCirle","color","className","style","backgroundColor","classNames","colors","allColors","getRandomColor","index","Math","floor","random","length","getHashedColor","str","hash","colorPalette","light","dark","getColorPalette","palette","WIDTH","defaultRecord","strokes","OrderedMap","mutationPairs","Map","undoStack","List","historyStack","defaultFactory","Record","getDefaultFlatState","DrawState","immutable","width","height","lastOp","this","getImmutable","get","getStrokeMap","last","size","uid","has","ratio","drawState","lastRecord","getHistoryStack","getUndoStack","unshift","set","type","nextRecord","first","pathData","stroke","v4","timestamp","Date","now","pushStroke","pathDataList","callback","newIDs","strokeList","map","push","pushStrokeList","prevRecord","currRecord","update","s","delete","merge","erased","hidden","filter","deleteAll","forEach","hideID","originUid","mutations","getMutationPairs","newUid","prevMutationUid","splitters","splitMap","prevUid","splitStrokes","validate","v5","NIL","String","prevStroke","op","eraseStrokes","mutateStrokes","undo","redo","toObject","flatState","operations","strokeMap","Object","entries","strokeData","ds","pushOperation","states","iterators","values","mergedStrokes","heap","Heap","s0","s1","iter","next","value","done","record","pop","test","slice","iterator","pageStates","pageInfos","TeamState","pageID","userID","getPageStates","getPageInfos","pageMap","m","notePage","setOp","getPageRatio","includesPage","prevDs","getOneState","setState","pageRec","newTS","state","teamPages","teamPage","teamStateMap","ignores","Set","Array","from","isEmpty","keys","every","useTransitionEnd","propertyName","active","resRef","useRef","useState","Promise","res","current","e","ActiveKeyCtx","createContext","useActiveKey","tuple","useContext","useDebugValue","ActiveKeyProvider","children","initKey","Provider","AsideOpenCtx","useAsideOpen","AsideOpenProvider","BASE_URL","process","getNoteID","roomCode","axios","data","statusCode","noteID","console","error","getTeamNoteInfo","loadTeamNoteInfo","cb","infoRes","noteInfo","updateTeamNote","withImg","method","url","responseType","onDownloadProgress","loaded","file","Blob","saveTeamNote","putNote","loadNote","note","name","pdf","pageOrder","removePageTimg","getUserID","formData","FormData","arrayBuffer","ab","append","headers","hashForage","localforage","updatePages","md5","JSON","stringify","getItem","lastHash","body","setItem","teamForage","getTeamNoteState","loadCachedTeamState","cachedState","params","modified","undefined","getAllNotes","allNotes","getAllTags","tags","addNewTag","getUid","newTag","notes","prevTags","deleteTag","editTag","tag","editNoteData","noteData","pickBy","v","lastTime","prevNoteInfo","prevNote","saveNoteInfo","tagID","createNewNote","noteWithPdf","deleteNote","prevTag","id","moveNoteTag","prevTagId","time","team","createTime","page","getPDFImages","images","pdfIndex","image","getOneImage","defaultNotePage","createEmptyNote","dayjs","format","createPage","marked","cached","localStorage","getUserName","uniqueNamesGenerator","dictionaries","animals","saveUserName","trim"],"sourceRoot":""}