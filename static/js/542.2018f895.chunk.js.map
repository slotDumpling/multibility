{"version":3,"file":"static/js/542.2018f895.chunk.js","mappings":"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","sources":["component/ColorCircle/ColorCircle.tsx","lib/color.ts","lib/draw/DrawState.ts","lib/draw/TeamState.ts","lib/hooks.tsx","lib/network/http.ts","lib/note/archive.ts","lib/note/note.ts","lib/user.ts"],"sourcesContent":["import classNames from \"classnames\";\nimport { FC } from \"react\";\n\nexport const ColorCirle: FC<{ color: string; className?: string }> = ({\n  color,\n  className,\n}) => {\n  const style = { backgroundColor: color };\n  return (\n    <div className={classNames(\"color-circle\", className)} style={style} />\n  );\n};\n","import { CSSProperties } from \"react\";\nimport hash from \"string-hash\";\nexport const colors = [\n  \"#f97316\",\n  \"#eab308\",\n  \"#84cc16\",\n  \"#22c55e\",\n  \"#10b981\",\n  \"#14b8a6\",\n  \"#06b6d4\",\n  \"#0ea5e9\",\n  \"#3b82f6\",\n  \"#6366f1\",\n  \"#8b5cf6\",\n  \"#a855f7\",\n  \"#d946ef\",\n  \"#ec4899\",\n  \"#f43f5e\",\n  \"#ef4444\",\n];\n\nexport const grayColors = [\"#000000\", \"#9ca3af\", \"#64748b\", \"#78716c\"];\nexport const allColors = [...grayColors, ...colors];\n\nexport const getRandomColor = () => {\n  const index = Math.floor(Math.random() * colors.length);\n  return colors[index]!;\n};\n\nexport const getHashedColor = (str: string) => {\n  const index = hash(str) % colors.length;\n  return colors[index];\n};\n\nconst colorPalette: Record<string, { light: string; dark: string }> = {\n  \"#f97316\": { light: \"#FFEDD5\", dark: \"#9A3412\" },\n  \"#eab308\": { light: \"#FEF9C3\", dark: \"#854D0E\" },\n  \"#84cc16\": { light: \"#ECFCCB\", dark: \"#3F6212\" },\n  \"#22c55e\": { light: \"#DCFCE7\", dark: \"#166534\" },\n  \"#10b981\": { light: \"#D1FAE5\", dark: \"#065F46\" },\n  \"#14b8a6\": { light: \"#CCFBF1\", dark: \"#115E59\" },\n  \"#06b6d4\": { light: \"#CFFAFE\", dark: \"#155E75\" },\n  \"#0ea5e9\": { light: \"#E0F2FE\", dark: \"#075985\" },\n  \"#3b82f6\": { light: \"#DBEAFE\", dark: \"#1E40AF\" },\n  \"#6366f1\": { light: \"#E0E7FF\", dark: \"#3730A3\" },\n  \"#8b5cf6\": { light: \"#EDE9FE\", dark: \"#5B21B6\" },\n  \"#a855f7\": { light: \"#F3E8FF\", dark: \"#6B21A8\" },\n  \"#d946ef\": { light: \"#FAE8FF\", dark: \"#86198F\" },\n  \"#ec4899\": { light: \"#FCE7F3\", dark: \"#9D174D\" },\n  \"#f43f5e\": { light: \"#FFE4E6\", dark: \"#9F1239\" },\n  \"#ef4444\": { light: \"#FEE2E2\", dark: \"#991B1B\" },\n};\n\nexport const getColorPalette = (color: string) => {\n  const palette = colorPalette[color] ?? { light: \"#E5E7EB\", dark: \"#374151\" };\n  return {\n    \"--light-color\": palette.light,\n    \"--dark-color\": palette.dark,\n  } as CSSProperties;\n};\n","import { List, Record, OrderedMap, Map } from \"immutable\";\nimport { NIL, v4, v5, validate } from \"uuid\";\nimport Heap from \"heap\";\n\nexport const WIDTH = 2000;\n\nexport interface Stroke {\n  uid: string;\n  pathData: string;\n  timestamp: number;\n}\n\nexport type StrokeRecord = globalThis.Record<string, Stroke>;\nexport type Mutation = [string, string];\nexport type Splitter = [string, string[]];\n\nexport type Operation =\n  | {\n      type: \"add\";\n      stroke: Stroke;\n    }\n  | {\n      type: \"erase\";\n      erased: string[];\n    }\n  | {\n      type: \"mutate\";\n      mutations: Mutation[];\n    }\n  | {\n      type: \"split\";\n      splitters: Splitter[];\n    }\n  | {\n      type: \"undo\";\n    }\n  | {\n      type: \"redo\";\n    };\n\ninterface DrawStateRecordType {\n  strokes: OrderedMap<string, Stroke>;\n  undoStack: List<DrawStateRecord>;\n  historyStack: List<DrawStateRecord>;\n}\n\ntype DrawStateRecord = Record<DrawStateRecordType>;\n\nconst defaultRecord: Readonly<DrawStateRecordType> = {\n  strokes: OrderedMap(),\n  undoStack: List(),\n  historyStack: List(),\n};\n\nconst defaultFactory = Record(defaultRecord);\n\nexport interface FlatState {\n  strokes: StrokeRecord;\n  operations?: Operation[];\n}\n\nexport const getDefaultFlatState = (): FlatState => {\n  return { strokes: {} };\n};\n\nexport class DrawState {\n  constructor(\n    private immutable: DrawStateRecord,\n    public readonly width: number,\n    public readonly height: number,\n    public lastOp?: Operation\n  ) {}\n\n  getImmutable() {\n    return this.immutable;\n  }\n\n  getUndoStack() {\n    return this.getImmutable().get(\"undoStack\");\n  }\n\n  getHistoryStack() {\n    return this.getImmutable().get(\"historyStack\");\n  }\n\n  getStrokeMap() {\n    return this.getImmutable().get(\"strokes\");\n  }\n\n  getStrokeList(): Stroke[] {\n    return this.getStrokeMap()\n      .toArray()\n      .map(([_, stroke]) => stroke);\n  }\n\n  getLastStroke() {\n    return this.getStrokeMap().last();\n  }\n\n  isEmpty() {\n    return this.getStrokeMap().size === 0;\n  }\n\n  hasStroke(uid: string) {\n    return this.getStrokeMap().has(uid);\n  }\n\n  static createEmpty(ratio: number, width = WIDTH) {\n    return new DrawState(defaultFactory(), width, width * ratio);\n  }\n\n  static undo(drawState: DrawState) {\n    const lastOp: Operation = { type: \"undo\" };\n    const lastRecord = drawState.getHistoryStack().last();\n    if (!lastRecord) return drawState;\n    const undoStack = drawState\n      .getUndoStack()\n      .unshift(drawState.getImmutable());\n    return new DrawState(\n      lastRecord.set(\"undoStack\", undoStack),\n      drawState.width,\n      drawState.height,\n      lastOp\n    );\n  }\n\n  static redo(drawState: DrawState) {\n    const lastOp: Operation = { type: \"redo\" };\n\n    const nextRecord = drawState.getUndoStack().first();\n    if (!nextRecord) return drawState;\n    return new DrawState(nextRecord, drawState.width, drawState.height, lastOp);\n  }\n\n  static addStroke(drawState: DrawState, pathData: string) {\n    const uid = v4();\n    const timestamp = Date.now();\n    const stroke = { pathData, uid, timestamp };\n    return DrawState.pushStroke(drawState, stroke);\n  }\n\n  static addStrokes(\n    drawState: DrawState,\n    pathDataList: string[],\n    IDs?: string[]\n  ) {\n    return DrawState.mutateStrokes(\n      drawState,\n      pathDataList.map((pathData) => {\n        const uid = v4();\n        IDs?.push(uid);\n        return [uid, pathData];\n      })\n    );\n  }\n\n  static pushStroke(drawState: DrawState, stroke: Stroke) {\n    const { uid } = stroke;\n    const prevRecord = drawState.getImmutable();\n    const currRecord = prevRecord\n      .update(\"strokes\", (s) => s.set(uid, stroke))\n      .update(\"historyStack\", (s) => s.push(prevRecord))\n      .delete(\"undoStack\");\n\n    const lastOp: Operation = { type: \"add\", stroke };\n\n    return new DrawState(currRecord, drawState.width, drawState.height, lastOp);\n  }\n\n  static eraseStrokes(drawState: DrawState, erased: string[]) {\n    if (erased.length === 0) return drawState;\n    const prevRecord = drawState.getImmutable();\n    let strokes = drawState.getStrokeMap();\n    const hidden = erased.filter((uid) => !strokes.has(uid));\n    strokes = strokes.deleteAll(erased);\n    hidden.forEach((hideID) => {\n      const uid = v4();\n      strokes = strokes.set(uid, {\n        uid,\n        timestamp: Date.now(),\n        pathData: \"HIDE_\" + hideID,\n      });\n    });\n\n    const currRecord = prevRecord\n      .set(\"strokes\", strokes)\n      .update(\"historyStack\", (s) => s.push(prevRecord))\n      .delete(\"undoStack\");\n\n    const lastOp: Operation = { type: \"erase\", erased };\n\n    return new DrawState(currRecord, drawState.width, drawState.height, lastOp);\n  }\n\n  static mutateStrokes(drawState: DrawState, mutations: Mutation[]) {\n    if (mutations.length === 0) return drawState;\n    const prevRecord = drawState.getImmutable();\n    let strokes = drawState.getStrokeMap();\n    mutations.forEach(\n      ([uid, pathData]) =>\n        (strokes = strokes.update(\n          uid,\n          { uid, pathData, timestamp: Date.now() },\n          (s) => ({ ...s, pathData })\n        ))\n    );\n    const currRecord = prevRecord\n      .set(\"strokes\", strokes)\n      .update(\"historyStack\", (s) => s.push(prevRecord))\n      .delete(\"undoStack\");\n\n    const lastOp: Operation = { type: \"mutate\", mutations };\n\n    return new DrawState(currRecord, drawState.width, drawState.height, lastOp);\n  }\n\n  static splitStrokes(drawState: DrawState, splitters: Splitter[]) {\n    if (splitters.length === 0) return drawState;\n    const splitMap = Map(splitters);\n    let strokes = OrderedMap<string, Stroke>();\n    const prevStrokes = drawState.getStrokeMap();\n    prevStrokes.forEach((stroke, prevUid) => {\n      const splitStrokes = splitMap.get(prevUid);\n      if (splitStrokes) {\n        strokes = strokes.merge(\n          splitStrokes.map((pathData, index) => {\n            // update legacy uid solution.\n            if (!validate(prevUid)) prevUid = v5(prevUid, NIL);\n\n            const uid = v5(String(index), prevUid);\n            const { timestamp } = stroke;\n            return [uid, { pathData, timestamp, uid }];\n          })\n        );\n      } else {\n        strokes = strokes.set(prevUid, stroke);\n      }\n    });\n    const prevRecord = drawState.getImmutable();\n    const currRecord = prevRecord\n      .set(\"strokes\", strokes)\n      .update(\"historyStack\", (s) => s.push(prevRecord));\n    const lastOp: Operation = { type: \"split\", splitters };\n    return new DrawState(currRecord, drawState.width, drawState.height, lastOp);\n  }\n\n  // sync with mutation.\n  static syncStrokeTime(drawState: DrawState, uid: string, timestamp: number) {\n    const prevStroke = drawState.getStrokeMap().get(uid);\n    if (!prevStroke) return;\n    prevStroke.timestamp = timestamp;\n  }\n\n  static pushOperation(drawState: DrawState, op: Operation) {\n    switch (op.type) {\n      case \"add\":\n        return DrawState.pushStroke(drawState, op.stroke);\n      case \"erase\":\n        return DrawState.eraseStrokes(drawState, op.erased);\n      case \"mutate\":\n        return DrawState.mutateStrokes(drawState, op.mutations);\n      case \"undo\":\n        return DrawState.undo(drawState);\n      case \"redo\":\n        return DrawState.redo(drawState);\n      case \"split\":\n        return DrawState.splitStrokes(drawState, op.splitters);\n    }\n  }\n\n  static flaten(drawState: DrawState): FlatState {\n    const strokes = drawState.getImmutable().get(\"strokes\").toObject();\n    return { strokes };\n  }\n\n  static loadFromFlat(\n    flatState: FlatState,\n    ratio: number,\n    width = WIDTH\n  ): DrawState {\n    const { strokes, operations } = flatState;\n    let ds = new DrawState(\n      defaultFactory().set(\"strokes\", OrderedMap(strokes)),\n      width,\n      width * ratio\n    );\n    operations?.forEach((op) => (ds = DrawState.pushOperation(ds, op)));\n    return ds;\n  }\n\n  static mergeStates(...states: DrawState[]) {\n    const iterators = states.map((ds) => ds.getStrokeMap().values());\n    let mergedStrokes = OrderedMap<string, Stroke>();\n    const heap = new Heap<[Stroke, number]>(\n      ([s0], [s1]) => s0.timestamp - s1.timestamp\n    );\n\n    iterators.forEach((iter, index) => {\n      const { value, done } = iter.next();\n      done || heap.push([value, index]);\n    });\n\n    while (heap.size() > 0) {\n      const record = heap.pop();\n      if (!record) break;\n      const [stroke, index] = record;\n      const { uid, pathData } = stroke;\n\n      if (/^HIDE_/.test(pathData)) {\n        const hideID = pathData.slice(5);\n        mergedStrokes = mergedStrokes.delete(hideID);\n      } else {\n        mergedStrokes = mergedStrokes.set(uid, stroke);\n      }\n\n      const iterator = iterators[index];\n      if (!iterator) break;\n      const { value, done } = iterator.next();\n      done || heap.push([value, index]);\n    }\n    return mergedStrokes;\n  }\n}\n","import { NotePage, TeamPageInfo, TeamPageRec } from \"lib/note/note\";\nimport { DrawState } from \"./DrawState\";\nimport { SetOperation } from \"./StateSet\";\nimport { Map, Record, Set } from \"immutable\";\n\ninterface TeamStateRecordType {\n  pageStates: Map<string, Map<string, DrawState>>;\n  pageInfos: Map<string, TeamPageInfo>;\n}\n\nconst defaultRecord: Readonly<TeamStateRecordType> = {\n  pageStates: Map(),\n  pageInfos: Map(),\n};\n\ntype TeamStateRecord = Record<TeamStateRecordType>;\nconst defaultFactory = Record(defaultRecord);\n\nexport class TeamState {\n  constructor(private immutable: TeamStateRecord) {}\n\n  getImmutable() {\n    return this.immutable;\n  }\n\n  getPageStates() {\n    return this.getImmutable().get(\"pageStates\");\n  }\n\n  getPageInfos() {\n    return this.getImmutable().get(\"pageInfos\");\n  }\n\n  getOneState(pageID: string, userID: string) {\n    return this.getPageStates().get(pageID)?.get(userID);\n  }\n\n  getOnePageStateMap(pageID: string) {\n    return this.getPageStates().get(pageID);\n  }\n\n  getPageRatio(pageID: string) {\n    return this.getPageInfos().get(pageID)?.ratio;\n  }\n\n  includesPage(pageID: string) {\n    return this.getPageStates().has(pageID);\n  }\n\n  setState(pageID: string, userID: string, drawState: DrawState) {\n    const pageMap = this.getPageStates().get(pageID);\n    if (!pageMap) return this;\n    return new TeamState(\n      this.getImmutable().update(\"pageStates\", (m) =>\n        m.set(pageID, pageMap.set(userID, drawState))\n      )\n    );\n  }\n\n  static createFromTeamPages(teamPages: TeamPageRec) {\n    let record = defaultFactory();\n    Object.entries(teamPages).forEach(([pageID, teamPage]) => {\n      const { states, ratio } = teamPage;\n      const pageMap = Map(\n        Object.entries(states).map(([userID, flatState]) => [\n          userID,\n          DrawState.loadFromFlat(flatState, ratio),\n        ])\n      );\n      record = record\n        .update(\"pageStates\", (m) => m.set(pageID, pageMap))\n        .update(\"pageInfos\", (m) => m.set(pageID, { ratio }));\n    });\n    return new TeamState(record);\n  }\n\n  addPage(pageID: string, notePage: NotePage) {\n    const { ratio } = notePage;\n    return new TeamState(\n      this.getImmutable()\n        .update(\"pageStates\", (m) => m.set(pageID, Map()))\n        .update(\"pageInfos\", (m) => m.set(pageID, { ratio }))\n    );\n  }\n\n  pushOperation(setOp: SetOperation, userID: string) {\n    const { pageID, ...op } = setOp;\n    const ratio = this.getPageRatio(pageID);\n    if (!this.includesPage(pageID) || !ratio) return this;\n    const prevDs =\n      this.getOneState(pageID, userID) || DrawState.createEmpty(ratio);\n\n    const ds = DrawState.pushOperation(prevDs, op);\n    return this.setState(pageID, userID, ds);\n  }\n\n  resetUser(userID: string, pageRec: globalThis.Record<string, NotePage>) {\n    let newTS: TeamState = this;\n    for (let [pageID, { state, ratio }] of Object.entries(pageRec)) {\n      const prevDS = newTS.getOneState(pageID, userID);\n      if (!prevDS) continue;\n      newTS = newTS.setState(\n        pageID,\n        userID,\n        DrawState.loadFromFlat(state, ratio)\n      );\n    }\n    return newTS;\n  }\n\n  static getValidUsers(\n    teamStateMap?: Map<string, DrawState>,\n    ignores = Set<string>()\n  ) {\n    if (!teamStateMap) return [];\n    return Array.from(\n      teamStateMap\n        .filter((ds) => !ds.isEmpty())\n        .deleteAll(ignores)\n        .keys()\n    );\n  }\n  static isEmpty(teamStateMap?: Map<string, DrawState>) {\n    return !teamStateMap || teamStateMap.every((ds) => ds.isEmpty());\n  }\n}\n","import React, {\n  createContext,\n  Dispatch,\n  FC,\n  PropsWithChildren,\n  SetStateAction,\n  TransitionEventHandler,\n  useContext,\n  useDebugValue,\n  useRef,\n  useState,\n} from \"react\";\n\nexport type Setter<T> = Dispatch<SetStateAction<T>>;\n\nexport function useTransitionEnd({\n  propertyName,\n  active = true,\n}: {\n  propertyName: string;\n  active?: boolean;\n}): [Promise<void>, TransitionEventHandler] {\n  const resRef = useRef(() => {});\n  const [promise] = useState(\n    () => new Promise<void>((res) => (resRef.current = res))\n  );\n  return [\n    promise,\n    (e) => {\n      if (e.propertyName === propertyName && active) resRef.current();\n    },\n  ];\n}\n\nconst ActiveKeyCtx = createContext<[string, Setter<string>]>([\"\", () => {}]);\nexport function useActiveKey() {\n  const tuple = useContext(ActiveKeyCtx);\n  useDebugValue(tuple[0]);\n  return tuple;\n}\n\nexport const ActiveKeyProvider: FC<PropsWithChildren<{ initKey: string }>> = ({\n  children,\n  initKey,\n}) => {\n  const tuple = useState(initKey);\n  return (\n    <ActiveKeyCtx.Provider value={tuple}>{children}</ActiveKeyCtx.Provider>\n  );\n};\n\nconst AsideOpenCtx = createContext<[boolean, Setter<boolean>]>([\n  false,\n  () => {},\n]);\nexport function useAsideOpen() {\n  const tuple = useContext(AsideOpenCtx);\n  useDebugValue(tuple[0]);\n  return tuple;\n}\n\nexport const AsideOpenProvider: FC<PropsWithChildren> = ({ children }) => {\n  const tuple = useState(false);\n  return (\n    <AsideOpenCtx.Provider value={tuple}>{children}</AsideOpenCtx.Provider>\n  );\n};\n","import axios from \"axios\";\nimport {\n  removePageTimg,\n  TeamNoteInfo,\n  TeamPageInfo,\n  TeamPageRec,\n} from \"lib/note/note\";\nimport { loadNote, saveTeamNote, updateTeamNote } from \"lib/note/archive\";\nimport { getUserID } from \"lib/user\";\nimport localforage from \"localforage\";\nimport md5 from \"md5\";\n\nexport const BASE_URL = process.env.REACT_APP_PUBLIC_SERVER_URL ?? \"\";\n// export const BASE_URL = process.env.REACT_APP_LOCAL_SERVER_URL ?? \"\";\naxios.defaults.baseURL = BASE_URL;\n\nexport async function getNoteID(roomCode: string) {\n  try {\n    const { data } = await axios.get(`code/${roomCode}`);\n    if (data.statusCode !== 200) return null;\n    return data.noteID as string;\n  } catch (e) {\n    console.error(e);\n    return null;\n  }\n}\n\ninterface InfoRes {\n  statusCode: number;\n  code: number;\n  noteInfo: TeamNoteInfo;\n  pageInfos: Record<string, TeamPageInfo>;\n}\n\nexport async function getTeamNoteInfo(noteID: string) {\n  try {\n    const { data } = await axios.get(`info/${noteID}`);\n    const { statusCode, ...res } = data as InfoRes;\n    if (statusCode !== 200) return null;\n    return res;\n  } catch (e) {\n    console.error(e);\n    return null;\n  }\n}\n\nexport async function loadTeamNoteInfo(\n  noteID: string,\n  cb?: (len: number) => void\n) {\n  try {\n    const infoRes = await getTeamNoteInfo(noteID);\n    if (!infoRes) return null;\n    const { noteInfo, pageInfos } = infoRes;\n\n    if (await updateTeamNote(noteID, noteInfo, pageInfos)) return infoRes;\n\n    if (noteInfo.withImg) {\n      const { data } = await axios({\n        method: \"GET\",\n        url: noteID,\n        responseType: \"blob\",\n        onDownloadProgress({ loaded }: ProgressEvent) {\n          cb?.(loaded);\n        },\n      });\n      const file = new Blob([data], { type: \"application/pdf\" });\n      await saveTeamNote(noteID, noteInfo, pageInfos, file);\n    } else {\n      await saveTeamNote(noteID, noteInfo, pageInfos);\n    }\n    return infoRes;\n  } catch (e) {\n    console.error(e);\n    return null;\n  }\n}\n\nexport async function putNote(noteID: string) {\n  const note = await loadNote(noteID);\n  if (!note) return false;\n  const { uid, name, withImg, pdf, pageOrder, pageRec } = note;\n  removePageTimg(pageRec);\n\n  try {\n    const { data } = await axios.put(`create/${noteID}`, {\n      userID: getUserID(),\n      pageRec,\n      noteInfo: { uid, name, withImg, pageOrder },\n    });\n\n    if (pdf) {\n      const formData = new FormData();\n      const ab = await pdf.arrayBuffer();\n      const file = new Blob([ab]);\n      formData.append(\"file\", file, noteID);\n      await axios({\n        method: \"POST\",\n        url: \"upload\",\n        data: formData,\n        headers: { \"Content-Type\": \"multipart/form-data\" },\n      });\n    }\n\n    if (data.statusCode !== 201) return false;\n    return true;\n  } catch (e) {\n    console.error(e);\n    return false;\n  }\n}\n\nconst hashForage = localforage.createInstance({ name: \"updateHash\" });\nexport async function updatePages(noteID: string) {\n  const note = await loadNote(noteID);\n  if (!note) return null;\n  const { uid, name, withImg, pageOrder, pageRec } = note;\n  removePageTimg(pageRec);\n  const noteInfo = { uid, name, withImg, pageOrder };\n\n  const hash = md5(JSON.stringify([pageRec, noteInfo]));\n  const lastHash = await hashForage.getItem<string>(noteID);\n  if (hash === lastHash) return true;\n\n  try {\n    const body = { userID: getUserID(), pageRec, noteInfo };\n    const { data } = await axios.put(`update/${noteID}`, body);\n    if (data.statusCode !== 201) return false;\n    await hashForage.setItem(noteID, hash);\n    return true;\n  } catch (e) {\n    console.error(e);\n    return false;\n  }\n}\n\nconst teamForage = localforage.createInstance({ name: \"teamState\" });\nexport async function getTeamNoteState(\n  noteID: string,\n  cb?: (len: number) => void\n) {\n  const cachedState = await loadCachedTeamState(noteID);\n  const hash = cachedState && md5(JSON.stringify(cachedState));\n\n  try {\n    const { data } = await axios.get(`state/${noteID}`, {\n      params: { userID: getUserID(), hash },\n      onDownloadProgress({ loaded }: ProgressEvent) {\n        cb?.(loaded);\n      },\n    });\n    const { statusCode, modified, teamPages } = data;\n    if (statusCode === 200 && modified) {\n      await teamForage.setItem(noteID, teamPages);\n      return teamPages as TeamPageRec;\n    }\n    return cachedState;\n  } catch (e) {\n    console.error(e);\n    return cachedState;\n  }\n}\n\nexport async function loadCachedTeamState(noteID: string) {\n  return (await teamForage.getItem<TeamPageRec>(noteID)) ?? undefined;\n}\n","import { Note, NoteInfo, NotePage, TeamNoteInfo, TeamPageInfo } from \"./note\";\nimport { getDefaultFlatState } from \"lib/draw/DrawState\";\nimport localforage from \"localforage\";\nimport { v4 as getUid } from \"uuid\";\nimport { pickBy } from \"lodash\";\n\nexport interface NoteTag {\n  uid: string;\n  name: string;\n  color: string;\n  notes: string[];\n}\n\nexport async function getAllNotes() {\n  const allNotes = await localforage.getItem<Record<string, NoteInfo>>(\n    \"ALL_NOTES\"\n  );\n  if (allNotes) return allNotes;\n  localforage.setItem(\"ALL_NOTES\", {});\n  return {};\n}\n\nexport async function getAllTags() {\n  const tags = await localforage.getItem<Record<string, NoteTag>>(\"ALL_TAGS\");\n  if (tags) return tags;\n  localforage.setItem(\"ALL_TAGS\", {});\n  return {};\n}\n\nexport async function addNewTag(name: string, color: string) {\n  const uid = getUid();\n  const newTag: NoteTag = {\n    uid,\n    name,\n    color,\n    notes: [],\n  };\n  const prevTags = await getAllTags();\n  const tags = { ...prevTags, [uid]: newTag };\n  await localforage.setItem(\"ALL_TAGS\", tags);\n\n  return tags;\n}\n\nexport async function deleteTag(uid: string) {\n  const prevTags = await getAllTags();\n  const { [uid]: _, ...tags } = prevTags;\n  await localforage.setItem(\"ALL_TAGS\", tags);\n\n  return tags;\n}\n\nexport async function editTag(tag: NoteTag) {\n  const prevTags = await getAllTags();\n  const tags = { ...prevTags, [tag.uid]: tag };\n  await localforage.setItem(\"ALL_TAGS\", tags);\n  return tags;\n}\n\nexport async function loadNote(uid: string) {\n  const note = await localforage.getItem<Note>(uid);\n  if (!note) return;\n  const pdf = await localforage.getItem<Blob>(`PDF_${uid}`);\n  if (pdf) return { ...note, pdf };\n  else return note;\n}\n\nexport async function editNoteData(uid: string, noteData: Partial<Note>) {\n  noteData = pickBy(noteData, (v) => v !== undefined);\n  if (\"pageRec\" in noteData) noteData.lastTime = Date.now();\n\n  const allNotes = await getAllNotes();\n  const { pageRec, pageOrder, ...noteInfo } = noteData;\n  const prevNoteInfo = allNotes[uid];\n  if (!prevNoteInfo) return;\n  allNotes[uid] = { ...prevNoteInfo, ...noteInfo };\n\n  await localforage.setItem(\"ALL_NOTES\", allNotes);\n  const prevNote = await loadNote(uid);\n  if (!prevNote) return;\n  await localforage.setItem(uid, { ...prevNote, ...noteData });\n}\n\nexport async function saveNoteInfo(noteInfo: NoteInfo) {\n  const { uid, tagID } = noteInfo;\n  const allNotes = await getAllNotes();\n  allNotes[uid] = noteInfo;\n  await localforage.setItem(\"ALL_NOTES\", allNotes);\n  const tags = await getAllTags();\n  const tag = tags[tagID];\n  if (tag) {\n    tag.notes.push(noteInfo.uid);\n    await localforage.setItem(\"ALL_TAGS\", tags);\n  }\n  return { tags, allNotes };\n}\n\nexport async function createNewNote(noteWithPdf: Note) {\n  const { pdf, ...note } = noteWithPdf;\n  await localforage.setItem(note.uid, note);\n  if (pdf) await localforage.setItem(`PDF_${note.uid}`, pdf);\n  const { pageRec, pageOrder, ...noteInfo } = note;\n  return await saveNoteInfo(noteInfo);\n}\n\nexport async function deleteNote(uid: string) {\n  const note = await loadNote(uid);\n  const allNotes = await getAllNotes();\n  const tags = await getAllTags();\n  if (!note) return { tags, allNotes };\n  await localforage.removeItem(uid);\n  await localforage.removeItem(`PDF_${uid}`);\n  delete allNotes[uid];\n  await localforage.setItem(\"ALL_NOTES\", allNotes);\n\n  const { tagID } = note;\n  const prevTag = tags[tagID];\n  if (prevTag) {\n    prevTag.notes = prevTag.notes.filter((id) => id !== uid);\n    await localforage.setItem(\"ALL_TAGS\", tags);\n  }\n  return { tags, allNotes };\n}\n\nexport async function moveNoteTag(noteID: string, tagID: string) {\n  const note = await loadNote(noteID);\n  const allNotes = await getAllNotes();\n  const tags = await getAllTags();\n  const noteInfo = allNotes[noteID];\n  if (!note || !noteInfo) return { tags, allNotes };\n\n  const { tagID: prevTagId } = note;\n  note.tagID = tagID;\n  await localforage.setItem(noteID, note);\n  noteInfo.tagID = tagID;\n  await localforage.setItem(\"ALL_NOTES\", allNotes);\n\n  const prevTag = tags[prevTagId];\n  if (prevTag) {\n    prevTag.notes = prevTag.notes.filter((id) => id !== noteID);\n  }\n  tags[tagID]?.notes.push(noteID);\n  await localforage.setItem(\"ALL_TAGS\", tags);\n  return { tags, allNotes };\n}\n\nexport async function saveTeamNote(\n  noteID: string,\n  noteInfo: TeamNoteInfo,\n  teamPages: Record<string, TeamPageInfo>,\n  file?: Blob\n) {\n  let note = await loadNote(noteID);\n  if (note) return;\n  const time = Date.now();\n  const pageRec: Record<string, NotePage> = {};\n  note = {\n    ...noteInfo,\n    tagID: \"DEFAULT\",\n    team: true,\n    pageRec,\n    pdf: file,\n    createTime: time,\n    lastTime: time,\n  };\n\n  // set empty state for each page\n  Object.entries(teamPages).forEach(([pageID, page]) => {\n    pageRec[pageID] = { ...page, state: getDefaultFlatState() };\n  });\n\n  // parse timg for each page\n  if (file) {\n    const { getPDFImages } = await import(\"./pdfImage\");\n    const { images } = await getPDFImages(file, 0.5);\n    Object.values(pageRec).forEach((page) => {\n      const { pdfIndex } = page;\n      if (!pdfIndex) return;\n      page.image = images[pdfIndex - 1];\n    });\n  }\n\n  await createNewNote(note);\n}\n\nexport async function updateTeamNote(\n  noteID: string,\n  noteInfo: TeamNoteInfo,\n  pageInfos: Record<string, TeamPageInfo>\n) {\n  let note = await loadNote(noteID);\n  if (!note) return false;\n  const { pageOrder } = noteInfo;\n  const { pageRec, pdf } = note;\n  const { getOneImage } = await import(\"./pdfImage\");\n\n  // parse timgs & set empty states for new pages.\n  for (let [pageID, teamPage] of Object.entries(pageInfos)) {\n    if (pageID in pageRec) continue;\n    const { pdfIndex } = teamPage;\n    const state = getDefaultFlatState();\n    const notePage: NotePage = { ...teamPage, state };\n    pageRec[pageID] = notePage;\n    if (pdf && pdfIndex) {\n      notePage.image = await getOneImage(pdf, pdfIndex, 0.5);\n    }\n  }\n  await editNoteData(noteID, { pageOrder, pageRec });\n  return true;\n}\n","import { getDefaultFlatState, FlatState } from \"lib/draw/DrawState\";\nimport { v4 as getUid } from \"uuid\";\nimport dayjs from \"dayjs\";\nexport interface NotePage {\n  ratio: number;\n  state: FlatState;\n  image?: string;\n  marked?: boolean;\n  pdfIndex?: number;\n}\n\nexport const defaultNotePage: Readonly<NotePage> = {\n  ratio: 1.5,\n  state: { strokes: {} },\n};\n\nexport interface TeamPageState {\n  states: Record<string, FlatState>;\n}\n\nexport interface TeamPageInfo {\n  ratio: number;\n  pdfIndex?: number;\n}\n\nexport type TeamPage = TeamPageInfo & TeamPageState;\nexport type TeamPageRec = Record<string, TeamPage>;\nexport interface TeamNote {\n  uid: string;\n  pageRec: TeamPageRec;\n}\n\nexport interface NoteInfo {\n  uid: string;\n  name: string;\n  tagID: string;\n  team: boolean;\n  withImg: boolean;\n  createTime: number;\n  lastTime: number;\n}\n\nexport type Note = NoteInfo & {\n  pdf?: Blob;\n  pageRec: Record<string, NotePage>;\n  pageOrder: string[];\n};\n\nexport interface TeamNoteInfo {\n  uid: string;\n  name: string;\n  pageOrder: string[];\n  withImg: boolean;\n}\n\nexport function createEmptyNote(): Note {\n  const pageID = getUid();\n  const time = Date.now();\n  return {\n    uid: getUid(),\n    name: `Note ${dayjs(time).format(\"HH:mm, ddd MMM D\")}`,\n    tagID: \"DEFAULT\",\n    team: false,\n    withImg: false,\n    createTime: time,\n    lastTime: time,\n    pageRec: {\n      [pageID]: {\n        ratio: 1.5,\n        state: getDefaultFlatState(),\n      },\n    },\n    pageOrder: [pageID],\n  };\n}\n\nexport function createPage(page?: NotePage): [string, NotePage] {\n  const pageID = getUid();\n  const newPage = page ?? {\n    ratio: 1.5,\n    state: getDefaultFlatState(),\n  };\n  return [pageID, newPage];\n}\n\nexport function removePageTimg(pageRec: Record<string, NotePage>) {\n  Object.values(pageRec).forEach((page) => {\n    delete page.image;\n    delete page.marked;\n  });\n}\n","import { animals, colors, uniqueNamesGenerator } from \"unique-names-generator\";\nimport { v4 as getUid } from \"uuid\";\n\nexport interface UserInfo {\n  userID: string;\n  userName: string;\n  online: boolean;\n}\n\nexport const getUserID = (() => {\n  let cached: string;\n  return () => {\n    if (cached) return cached;\n    let userID = localStorage.getItem(\"USER_ID\");\n    if (!userID) {\n      userID = getUid();\n      localStorage.setItem(\"USER_ID\", userID);\n    }\n    cached = userID;\n    return userID;\n  };\n})();\n\nexport const getUserName = () => {\n  let name = localStorage.getItem(\"USER_NAME\");\n  if (!name) {\n    name = uniqueNamesGenerator({\n      dictionaries: [colors, animals],\n      style: \"capital\",\n    });\n    localStorage.setItem(\"USER_NAME\", name);\n  }\n  return name;\n};\n\nexport const saveUserName = (name: string) => {\n  name = name.trim();\n  if (!name) return false;\n  else localStorage.setItem(\"USER_NAME\", name);\n  return true;\n};\n"],"names":["ColorCirle","color","className","style","backgroundColor","classNames","colors","allColors","getRandomColor","index","Math","floor","random","length","getHashedColor","str","hash","colorPalette","light","dark","getColorPalette","palette","WIDTH","defaultRecord","strokes","OrderedMap","undoStack","List","historyStack","defaultFactory","Record","getDefaultFlatState","DrawState","immutable","width","height","lastOp","this","getImmutable","get","getStrokeMap","toArray","map","last","size","uid","has","ratio","drawState","lastRecord","getHistoryStack","getUndoStack","unshift","set","type","nextRecord","first","pathData","stroke","v4","timestamp","Date","now","pushStroke","pathDataList","IDs","mutateStrokes","push","prevRecord","currRecord","update","s","delete","erased","hidden","filter","deleteAll","forEach","hideID","mutations","splitters","splitMap","Map","prevUid","splitStrokes","merge","validate","v5","NIL","String","prevStroke","op","eraseStrokes","undo","redo","toObject","flatState","operations","ds","pushOperation","states","iterators","values","mergedStrokes","heap","Heap","s0","s1","iter","next","value","done","record","pop","test","slice","iterator","pageStates","pageInfos","TeamState","pageID","userID","getPageStates","getPageInfos","pageMap","m","notePage","setOp","getPageRatio","includesPage","prevDs","getOneState","setState","pageRec","newTS","Object","entries","state","teamPages","teamPage","teamStateMap","ignores","Set","Array","from","isEmpty","keys","every","useTransitionEnd","propertyName","active","resRef","useRef","useState","Promise","res","current","e","ActiveKeyCtx","createContext","useActiveKey","tuple","useContext","useDebugValue","ActiveKeyProvider","children","initKey","Provider","AsideOpenCtx","useAsideOpen","AsideOpenProvider","BASE_URL","process","getNoteID","roomCode","axios","data","statusCode","noteID","console","error","getTeamNoteInfo","loadTeamNoteInfo","cb","infoRes","noteInfo","updateTeamNote","withImg","method","url","responseType","onDownloadProgress","loaded","file","Blob","saveTeamNote","putNote","loadNote","note","name","pdf","pageOrder","removePageTimg","getUserID","formData","FormData","arrayBuffer","ab","append","headers","hashForage","localforage","updatePages","md5","JSON","stringify","getItem","lastHash","body","setItem","teamForage","getTeamNoteState","loadCachedTeamState","cachedState","params","modified","undefined","getAllNotes","allNotes","getAllTags","tags","addNewTag","getUid","newTag","notes","prevTags","deleteTag","editTag","tag","editNoteData","noteData","pickBy","v","lastTime","prevNoteInfo","prevNote","saveNoteInfo","tagID","createNewNote","noteWithPdf","deleteNote","prevTag","id","moveNoteTag","prevTagId","time","team","createTime","page","getPDFImages","images","pdfIndex","image","getOneImage","defaultNotePage","createEmptyNote","dayjs","format","createPage","marked","cached","localStorage","getUserName","uniqueNamesGenerator","dictionaries","animals","saveUserName","trim"],"sourceRoot":""}